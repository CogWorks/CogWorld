;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Filename     : SendMaill.lisp;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Author       : Evan Patton, Mike Schoelles;; Copyright    : (C) 2009 CogWorks Laboratory;; Address      : Cognitive Science Department;;              : Rennselaer Polytechnic Institute;;              : Troy, NY 12180;;              : schoem@rpi.edu;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;#|You must have Mail.app configured with valid SMTP settings to send a message. To send: call (send-mail), it takes a string or list of strings for recipients, and keywords :cc, :subject, and :body. :cc will take an email address or list of email addresses to CC. :subject takes a string which is the subject line, and :body takes a string which becomes the body of the message.The script will launch Mail, send the email, and then quit Mail.This new file I'm sending has a new function: (send-mail-smtp) which uses SMTP to talk directly to mail.rpi.edu in order to bypass having to use AppleScript to send mail via Mail.app. Here are the parameters:sender: A string containing the email address of the sender, could be the grad student running the experimentaddresses: A string containing a single address or list containing multiple addresses to send email to.subject: The content of the subject linebody: Contents of the emailkeys:cc: Carbon copy the email to the addresses listed (follows same rules as addresses above)echo: nil, t, or a stream to send a copy of the communications (both client and server)I will send a test message using it shortly after this one.|#(defconstant *MAIL-SCRIPT-LOCATION*  (current-pathname "MailScript.scpt") )(defparameter *SMTP-SERVER* "mail.rpi.edu")(defparameter *SMTP-PORT* 25)(defun url-escape (str)  (let ((result "")        (c nil))    (dotimes (i (length str) result)      (setf c (elt str i))      (cond ((and (char>= c #\0) (char<= c #\9))             (setf result (format nil "~A~C" result c)))            ((and (char>= c #\A) (char<= c #\Z))             (setf result (format nil "~A~C" result c)))            ((and (char>= c #\a) (char<= c #\z))             (setf result (format nil "~A~C" result c)))            (t             (setf result (format nil "~A%~2,'0X" result (char-code c))))))))(defun send-mail-applescript (mailto)  (format t "osascript -e ~A '~A'" *MAIL-SCRIPT-LOCATION* mailto)  (sys:call-system (format nil "osascript ~A '~A'" *MAIL-SCRIPT-LOCATION* mailto)))(defun send-mail-smtp (sender addresses subject body &key cc echo)  (let ((recipients nil)        (stream nil))    (cond ((listp addresses)           (setf recipients (copy-list addresses)))          ((stringp addresses)           (setf recipients (list addresses)))          (t           (error "Invalid value supplied for addresses")))    (cond ((and cc (listp cc))           (setf recipients (append recipients (copy-list cc))))          ((and cc (stringp cc))           (setf recipients (append recipients (list cc))))          (cc           (error "Invalid value supplied for cc")))    (setf stream (comm:open-tcp-stream *SMTP-SERVER* *SMTP-PORT* :direction :io))    (if (not stream) (error "Unable to connect to SMTP server."))    (format echo "~A~&" (read-line stream))    (format echo "HELO cogworks.cogsci.rpi.edu~%")    (format stream "HELO cogworks.cogsci.rpi.edu~%")    (finish-output stream)    (format echo "~A~&" (read-line stream))    (format echo "MAIL FROM:<~A>~%" sender)    (format stream "MAIL FROM:<~A>~%" sender)    (finish-output stream)    (dolist (r recipients)      (format echo "~A~&" (read-line stream))      (format echo "RCPT TO:<~A>~%" r)      (format stream "RCPT TO:<~A>~%" r)      (finish-output stream))    (format echo "~A~&" (read-line stream))    (format echo "DATA~%")    (format stream "DATA~%")    (finish-output stream)    (format echo "~A~&" (read-line stream))    (format echo "From: ~A~%" sender)    (format stream "From: ~A~%" sender)    (cond ((listp addresses)           (dolist (addr addresses)             (format echo "To: ~A~%" addr)             (format stream "To: ~A~%" addr)))          ((stringp addresses)           (format echo "To: ~A~%" addresses)           (format stream "To: ~A~%" addresses)))    (cond ((and cc (listp cc))           (dolist (addr cc)             (format echo "Cc: ~A~%" addr)             (format stream "Cc: ~A~%" addr)))          ((stringp cc)           (format echo "Cc: ~A~%" cc)           (format stream "Cc: ~A~%" cc)))    (format echo "Subject: ~A~%~%" subject)    (format stream "Subject: ~A~%~%" subject)    (format echo "~A" body)    (format stream "~A" body)    (format echo "~%.~%")    (format stream "~%.~%")    (finish-output stream)    (format echo "~A~&" (read-line stream))    (format echo "QUIT~%")    (format stream "QUIT~%")    (finish-output stream)    (format echo "~A~&" (read-line stream))    (close stream)))(defun send-mail (addresses &key cc subject body)  (cond ((listp addresses)         (setf addresses (format nil "~{~A~^,~}" addresses))))  (if (not (stringp addresses)) (error "You must supply an address as a string or a list of addresses."))  (cond ((and cc (listp cc))         (setf cc (format nil "~{~A~^,~}" cc))))  (let ((mailto "mailto:"))    (setf mailto (format nil "~A~A" mailto addresses))    (if (or cc subject body) (setf mailto (format nil "~A?" mailto)))    (if cc        (setf mailto (format nil "~Acc=~A" mailto cc)))    (if subject        (if cc            (setf mailto (format nil "~A&subject=~A" mailto (url-escape subject)))          (setf mailto (format nil "~Asubject=~A" mailto (url-escape subject)))))    (if body        (if (or cc subject)            (setf mailto (format nil "~A&body=~A" mailto (url-escape body)))          (setf mailto (format nil "~A?body=~A" mailto (url-escape body)))))    (send-mail-applescript mailto)))(defun get-system-email-address ()  "rpi.cwl@gmail.com") ;"schoem@rpi.edu")(defun conv-to-list (x)  (cond (x         (read-from-string (concatenate 'string "(" (string-trim '(#\Space #\. #\?) x) ")")))))(defun extract-id-from-filename(fn)  (let ((pos (position #\. fn)))    (subseq fn (- pos (length "yrmndy_hrmnsc")) pos)))(let ((subj-id-accum nil))(defun mail-history-files (exp-name  &key (from (get-system-email-address)) to path)  (let* ((files (directory (aif path it (capi:prompt-for-directory ""))))         (name (if (stringp exp-name) exp-name (write-to-string exp-name)))         (len  (length name ) )         (body ""))    (if (null to)        (setq to (capi:prompt-for-string "Enter address or coma separated address list:")))     (when to           (dolist (f files)         (setq f (namestring f))         (when (and (> (length f) (+ len 21)) ;"id.history"                   (equalp (subseq (file-namestring f) 0 len) exp-name)                   (equal (subseq (reverse f) 0 (length "history"))  (reverse "history")))           (with-open-file (fs f :direction :input)              (read-line fs)            (let* ((ln (ignore-errors (read-line fs)))                   (lst (if ln (read-from-string (concatenate 'string "(" (string-trim '(#\Space #\. #\?) ln) ")"))))                   (rin (sixth lst)))              (when ln                (setq body (concatenate 'string body ln (format nil "~%")))                     (push (list (aes8:rin->id rin) (extract-id-from-filename (file-namestring f))) subj-id-accum))))))       (if (plusp (length body))          (send-mail-smtp from to name body)))))(defun send-ids-to-server () (dolist (ids (reverse subj-id-accum))   (destructuring-bind (pid sid) ids     (add-ids pid sid)))))(defun onelinepage (server port page data)  (let ((answer ""))    (with-open-stream (http (comm:open-tcp-stream                              server port))      (format http "POST /~a HTTP/1.1~C~CHost: ~a~C~CContent-type: application/x-www-form-urlencoded~C~CContent-length: ~a~C~CConnection: close~C~C~C~C~a~C~C"              page               (code-char 13) (code-char 10)              server              (code-char 13) (code-char 10)              (code-char 13) (code-char 10)              (length data)              (code-char 13) (code-char 10)              (code-char 13) (code-char 10)              (code-char 13) (code-char 10)              data              (code-char 13) (code-char 10))      (force-output http)      ;(write-string "Waiting to reply...")      (loop for ch = (read-char-no-hang http nil :eof)            until ch            do ;(write-char #\.)            (sleep 0.25)            finally (unless (eq ch :eof)                      (unread-char ch http)))       (terpri)      (loop for line = (read-line http nil nil)            while line            do (if (find #\. line) (setq answer line))))    answer))(defun get-sids (pid)  (onelinepage "cog3.cogsci.rpi.edu" 8080 "ids.cgi"               (format nil "action=get&pid=~a&usr=cwl&pwd=IDSdbsimon" pid)))(defun get-pids (sid)  (onelinepage "cog3.cogsci.rpi.edu" 8080 "ids.cgi"               (format nil "action=get&sid=~a&usr=cwl&pwd=IDSdbsimon" sid)))(defun add-ids (pid sid)  (onelinepage "cog3.cogsci.rpi.edu" 8080 "ids.cgi"                (format nil "action=put&pid=~a&sid=~a&usr=cwl&pwd=IDSdbsimon" pid sid)))(defun finish-experiment (exp-name to)  (mail-history-files exp-name :to to)  (send-ids-to-server))    