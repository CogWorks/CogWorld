;;;  -*- mode: LISP; Syntax: COMMON-LISP;  Base: 10 -*-
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 
;;; Author      : Dan Bothell
;;; Copyright   : (c) 2004 Dan Bothell
;;; Availability: Covered by the GNU LGPL, see LGPL.txt
;;; Address     : Department of Psychology 
;;;             : Carnegie Mellon University
;;;             : Pittsburgh, PA 15213-3890
;;;             : db30@andrew.cmu.edu
;;; 
;;; 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 
;;; Filename    : scheduling.lisp
;;; Version     : 1.5
;;; 
;;; Description : Event creation and scheduling and schedule running functions.
;;; 
;;; Bugs        : [X] Need to fix/remove the update functions from the modules
;;;             :     because how they get called prevents one from scheduleing
;;;             :     events correctly during one (in particular the device 
;;;             :     device-update-attended-loc doesn't accept the time parameters
;;;             :     but just adding that is really just a hack).
;;;             : [ ] There isn't a way to delete an "after" event that was waiting
;;;             :     but then got scheduled since it's no longer the same event
;;;             :     in the queue.
;;;
;;; To do       : [ ] Finish documentation.
;;;             : [x] Add an equivalent to the real-time-slack-hook-fn in rpm.
;;;             : [ ] Consider a global randomize time flag and/or parameter to the
;;;             :     scheduling functions.
;;;             : [x] The break events and "stopping reason" trace don't go to
;;;             :     the output of all models but probably should so that if
;;;             :     the traces are split at the model level they all show it.
;;;
;;; 
;;; ----- History -----
;;;
;;; 2004.08.16 Dan
;;;             : Creation
;;; 2004.12.06 Dan
;;;             : Updated a warning message because I found it uninformative.
;;;             : Tried to fit things to 80 char line width.
;;; 2005.01.12 Dan
;;;             : Because the device is now a module it doesn't need to
;;;             : be handled specially in set-mp-clock.
;;; 2005.01.27 Dan
;;;             : * Modified run-one-event to use filter-output-events which
;;;             :   is now part of the printing module to determine if the
;;;             :   trace should be displayed.
;;; 2005.02.03 Dan
;;;             : * Removed the format call from the periodic action's details.
;;; 2005.02.14 Dan
;;;             : * Added the run-until-condition function.
;;; 2005.02.16 Dan
;;;             : * Some general cleanup and added the "stopping reason" output
;;;             :   to the run functions.
;;; 2005.02.22 Dan
;;;             : * Cleaned up the stopping reason output.
;;;             : * Fixed a bug in run-full-time by just making it use
;;;             :   run-until-time.
;;; 2005.02.25 Dan
;;;             : * Made run work more like pm-run in that if there are future
;;;             :   events it will work like run-full-time instead of just
;;;             :   stopping.
;;; 2005.02.28 Dan
;;;             : * Switched the stopping reason output from model-output to
;;;             :   meta-p-output (which I've put back into things) because
;;;             :   model-output doesn't work in a multi-model situation.
;;; 2005.04.20 Dan
;;;             : * Changed add-pre/post-event-hook so that fboundp doesn't
;;;             :   cause problems for Lispworks with lambdas.
;;; 2005.05.20 Dan
;;;             : * Fixed a bug in run-until-time (caused primarily when
;;;             :   run-full-time used) where a non-rounded time could cause
;;;             :   the system to get stuck.
;;; 2005.12.08 Dan
;;;             : * Fixed a bug in the output of the events generated by
;;;             :   schedule-periodic-event and periodic-action.
;;; 2006.01.25 Dan
;;;             : * Modifying all the "run" functions so that when they end 
;;;             :   a "run-terminated" event is passed to all the models if
;;;             :   it terminates other than due to a break.  This way, the
;;;             :   event hooks can detect when a run ends (either a break
;;;             :   event or an event with the run-terminated action) which
;;;             :   makes adding additional tracing and other tools easier.
;;; 2006.01.26 Dan
;;;             : * Added an optional parameter to the add-pre/post-event-hook
;;;             :   functions to suppress the warning if one adds a hook that's
;;;             :   already on the list.  It just returns nil in that case now.
;;;             :   This helps because the hook is at the meta-process level,
;;;             :   but one may have a module (at the model level) that needs
;;;             :   to add such a hook and not want to see the warning if there
;;;             :   are multiple models loaded and using it.
;;; 2006.01.30 Dan
;;;             : * Changed the run-terminated event to a maintenance event.
;;;             : * Added the keyword param :include-maintenance to the schedule-
;;;             :   after-* functions which indicates whether or not to include
;;;             :   maintenance events in those that can trigger it (it defaults
;;;             :   to nil).  This keeps things from getting scheduled after 
;;;             :   events that don't do anything for the model.
;;;             : * Added the schedule-maintenance-event-relative function to
;;;             :   be able to schedule maintenance events.  Could make it a
;;;             :   switch on the existing functions, but for now at least
;;;             :   I've decided to use a different function.
;;; 2006.02.24 Dan
;;;             : * Fixed a bug in run-until-time that caused it to not work
;;;             :   if there was more than one model defined.
;;; 2006.02.27 Dan [1.2]
;;;             : * Modified run-schd-queue and set-mp-clock so that they
;;;             :   now use the "real time" control functions that can be set
;;;             :   for the meta-process using mp-real-time-management.
;;; 2006.02.28 Dan
;;;             : * Added a schedule-maintenance-event function and changed
;;;             :   run-until-time to actually use it.
;;; 2006.03.03 Dan
;;;             : * Modified run-sched-queue to use the max-delta-time 
;;;             :   property set with mp-real-time-management.
;;;             :   New (non-maintenance) "dummy" events will be automatically 
;;;             :   generated to occur in any time slice that needs them. 
;;; 2006.03.08 Dan
;;;             : * Fixed a bug with schedule-break-after-module because it
;;;             :   didn't set the model for the event, so never matched up
;;;             :   with a new event to get scheduled.
;;;
;;; 2006.05.02 Dan
;;;             : * Noted an issue with the update function of modules and put
;;;             :   it under bugs above.
;;; 2006.07.13 Dan
;;;             : * Fixed a bug with run-until-time that caused it to jump
;;;             :   back in time if the end-time had already passed.
;;; 2006.07.14 Dan
;;;             : * Added another output to run-n-events to make it clearer
;;;             :   in the trace why it stopped - differentiate hitting the
;;;             :   event-count from just running out of events.
;;; 2006.07.18 Dan
;;;             : * Removed the schedule-maintenance-* functions and
;;;             :   replaced them with a keyword :maintenance t/nil
;;;             :   in the regular schedule-* functions.
;;;             : * Updated all references to schedule-maintenance-* with
;;;             :   the correct schedule-* function.
;;;             : * As a saftey check those maintenance functions now just
;;;             :   print a warning to let people know there was a change.
;;; 2006.07.20 Dan
;;;             : * Fixed a bug in schedule-periodic-event because it tried
;;;             :   to take the symbol-name of an interpreted function if that
;;;             :   was passed as the action.
;;;             : * Updated conditions-met because a break event doesn't have
;;;             :   a model so if it's waiting it'll never match to any specific
;;;             :   model so should instead match to any model.
;;;             : * Fixed update waiting-events because it didn't distinguish
;;;             :   between break events and normal events which caused a
;;;             :   problem for schedule-break-after-module.
;;; 2006.07.28 Dan
;;;             : * Fixed the warning in delete-event-hook.
;;; 2007.01.19 Dan
;;;             : * Fixed a bug in periodic-action because it had the same 
;;;             :   symbol-name issue as schedule-periodic-event did...
;;; 2007.04.16 Dan
;;;             : * Updated the version to 1.3.
;;;             : * Made the run-terminated action actually do something.  It
;;;             :   checks the :ncnar parameter and if true calls normalize-
;;;             :   chunk-names.  
;;; 2007.05.04 Dan
;;;             : * Added a general method for delete-event (specified the class
;;;             :   t) so that it doesn't throw an error if a bad value is
;;;             :   provided.
;;; 2007.07.13 Dan
;;;             : * Changed run-terminated so that when :ncnar is set to delete
;;;             :   it actually forces the chunk deletion and name uninterning.
;;; 2007.08.28 Dan
;;;             : * Added s and w options to run-step to show the event queue and
;;;             :   the waiting events during the stepping.
;;; 2007.10.31 Dan
;;;             : * Fixed a bug with the printing of break events in run-one-event -
;;;             :   if there was more than one model the event wasn't being output.
;;;             :   Now check for break events and use meta-p-output instead of 
;;;             :   model-output since a break doesn't have a model.
;;;             : * Changed the model name used for the terminating event output
;;;             :   to just '- so that it will always line up even if the longest
;;;             :   model name is only 1 character.
;;; 2007.11.30 Dan
;;;             : * Changed run-terminated to use awhen so it doesn't have to
;;;             :   call sgp twice (an expensive call).
;;; 2007.12.13 Dan
;;;             : * Fixed a bug in schedule-periodic-event because if it was
;;;             :   passed an action that wasn't a symbol the call to fboundp
;;;             :   for the details would break.
;;; 2008.05.02 Dan
;;;             : * Added another option to run-step (b) for showing the buffer
;;;             :   contents.
;;; 2008.10.23 Dan
;;;             : * Updated run-terminated to use the new flags for normalizing.
;;; 2008.10.28 Dan
;;;             : * Changed the model-output in run-one-event so that the 
;;;             :   event string isn't directly used as the format string to
;;;             :   avoid issues with tildes in the output.
;;; 2009.03.10 Dan [1.4]
;;;             : * Moved the code to check for sending module "updates" from
;;;             :   set-mp-clock to run-sched-queue.  This has two effects:
;;;             :   - Updates occur at the end of a time step now and not the
;;;             :     "top of the next one".
;;;             :   - It's safe to schedule events during an "update" (fixes
;;;             :     the bug listed under bugs).
;;; 2009.04.29 Dan
;;;             : * Added checks for recursive calls to run and now signal a
;;;             :   warning and just abort the later calls.
;;; 2009.12.04 Dan [1.5]
;;;             : * Updated the real-time running code to allow for a little
;;;             :   more responsiveness when a slack-hook is provided.  Events
;;;             :   can be scheduled during the slack-hook and they can jump
;;;             :   "back" in time if desired (which would require explicitly
;;;             :   scheduling them for that time since "now" has still already 
;;;             :   moved) which likely requires a custom clock as well (to
;;;             :   know when "now" is relative to where the event queue is).
;;;             : * In addition to that, if the allow-dynamics is also provided 
;;;             :   then events which were scheduled using one of the after
;;;             :   scheduling functions and are flagged as dynamic will be 
;;;             :   sensitive to those new events (or events that they schedule)
;;;             :   and may be moved back in time if appropriate (conflict-resolution 
;;;             :   is now scheduled as dynamic so it could move back).
;;;             : * It is important to note however that the scheduling code is
;;;             :   still not thread safe -- any asynchronous event scheduling
;;;             :   should occur in the slack-hook (or some other safe place) and 
;;;             :   be protected appropriately.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; General Docs:
;;; 
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; Public API:
;;;
;;;
;;; run 
;;; 
;;; (defun run (run-time &key (real-time nil)))
;;; 
;;; run-time is a time in seconds 
;;; real-time is either t or nil
;;; 
;;; If there is a current meta-process this will run the scheduler for that 
;;; meta-process with a stopping condition that the clock will be advanced by 
;;; no more than run-time seconds. If real-time is t, then the clock will be 
;;; advanced in step with actual time instead of simulating time as fast as 
;;; possible.
;;; 
;;; After running the scheduler a line will be output in the trace indicating 
;;; why the run stopped, which will be one of the following conditions: the 
;;; requested amount of time has passed, there are no events left to process, or 
;;; a break event occurred.
;;; 
;;; run returns three values.  
;;; 
;;; If there is no current meta-process all three are nil.
;;; 
;;; If there is a current meta-process, then the first value is the amount
;;; of simulated time that passed during the call to run.  The second is the 
;;; number of events that were processed from the event queue, and the third
;;; will be t if the run terminated due to a break event or nil if it terminated 
;;; for any other reason.
;;;    
;;; run-full-time
;;; 
;;; (defun run-full-time (run-time &key (real-time nil)))
;;; 
;;; run-time is a time in seconds 
;;; real-time is either t or nil
;;; 
;;; If there is a current meta-process this will run the scheduler for that
;;; meta-process with a stopping condition that the clock will be advanced by 
;;; exactly run-time seconds unless a break event occurs. If real-time is t, 
;;; then the clock will be advanced in step with actual time instead of 
;;; simulating time as fast as possible.
;;; 
;;; After running the scheduler a line will be output in the trace indicating 
;;; why the run stopped, which will be one of the following conditions: the 
;;; requested amount of time has passed or a break event occurred.
;;; 
;;; run-full-time returns three values.  
;;; 
;;; If there is no current meta-process all three are nil.
;;; 
;;; If there is a current meta-process, then the first value is the amount
;;; of simulated time that passed during the call to run-full-time.  The second 
;;; is the number of events that were processed from the event queue, and the
;;; third will be t if the run terminated due to a break event or nil if it 
;;; terminated for any other reason.
;;; 
;;; run-until-time
;;; 
;;; (defun run-until-time (end-time &key (real-time nil)))
;;; 
;;; end-time is a time in seconds 
;;; real-time is either t or nil
;;; 
;;; If there is a current meta-process this will run the scheduler for that
;;; meta-process with a stopping condition that the clock will be advanced to
;;; the explicit end-time if the current time is not already greater than 
;;; end-time and no break event occurs.  If real-time is t, then the clock will
;;; be advanced in step with actual time instead of simulating time as fast as
;;; possible.
;;; 
;;; After running the scheduler a line will be output in the trace indicating
;;; why the run stopped, which will be one of the following conditions: the
;;; requested end-time has already been passed, the requested end-time has 
;;; been reached, or a break event occurred.
;;; 
;;; run-until-time returns three values.  
;;; 
;;; If there is no current meta-process all three are nil.
;;; 
;;; If there is a current meta-process, then the first value is the amount
;;; of simulated time that passed during the call to run-until-time.  The second 
;;; is the number of events that were processed from the event queue, and the
;;; third will be t if the run terminated due to a break event or nil if it
;;; terminated for any other reason.
;;; 

;;; run-until-condition
;;; 
;;; (defun run-until-condition (condition &key (real-time nil)))
;;; 
;;; condition is a function or function name that takes no arguments 
;;; real-time is either t or nil
;;; 
;;; If there is a current meta-process this will run the scheduler for that
;;; meta-process with the stopping condition being until the codition
;;; function returns t or a break event occurs.  If real-time is t, then the 
;;; clock will be advanced in step with actual time instead of simulating time 
;;; as fast as possible.
;;;
;;; After running the scheduler a line will be output in the trace indicating
;;; why the run stopped, which will be one of the following conditions: the
;;; requested condition was t or a break event occurred.
;;; 
;;; run-until-time returns three values.  
;;; 
;;; If there is no current meta-process all three are nil.
;;; 
;;; If there is a current meta-process, then the first value is the amount
;;; of simulated time that passed during the call to run-until-time.  The second 
;;; is the number of events that were processed from the event queue, and the
;;; third will be t if the run terminated due to a break event or nil if it
;;; terminated for any other reason.



;;; run-n-events
;;; 
;;; (defun run-n-events (event-count &key (real-time nil)))
;;; 
;;; event-count is a positive integer 
;;; real-time is either t or nil
;;; 
;;; If there is a current meta-process this will run the scheduler for
;;; that meta-process with a stopping condition that at most event-count events
;;; are executed.   If real-time is t, then the clock will be advanced in step
;;; with actual time instead of simulating time as fast as possible.
;;; 
;;; After running the scheduler a line will be output in the trace indicating
;;; why the run stopped, which will be one of the following conditions: there
;;; were no more events to execute, event-count events were processed, or a 
;;; break event occurred.
;;; 
;;; run-n-events returns three values.  
;;; 
;;; If there is no current meta-process all three are nil.
;;; 
;;; If there is a current meta-process, then the first value is the amount
;;; of simulated time that passed during the call to run-n-events.  The second
;;; is the number of events that were processed from the event queue, and the
;;; third will be t if the run terminated due to a break event or nil if it
;;; terminated for any other reason.
;;; 
;;; run-step
;;; 
;;; (defun run-step ())
;;; 
;;; If there is a current meta-process run-step will execute events from
;;; the event queue one at a time displaying each before execution on 
;;; *standard-output* and prompting the user to decide whether to process the
;;; event, delete it, or end the stepping (other features may be added over 
;;; time).  It will continue until the queue is empty, a break event is 
;;; executed, or the user requests it to quit.  
;;;    
;;; run-step returns three values.  
;;; 
;;; If there is no current meta-process all three are nil.
;;; 
;;; If there is a current meta-process, then the first value is the amount
;;; of simulated time that passed during the call to run-step.  The second is
;;; the number of events that were processed from the event queue (not counting
;;; those that were deleted), and the third will be t if the run terminated 
;;; due to a break event or nil if it terminated for any other reason.
;;; 
;;; 
;;; schedule-event
;;; 
;;; (defun schedule-event (time action 
;;;                        &key (module :none) (destination nil)
;;;                             (priority 0)(params nil) (details nil)
;;;                             (output t)))
;;; 
;;; time a time in seconds which should be a non-negative number
;;; action a function or function-name
;;; module a symbol that names the module which is scheduling the event
;;; destination a symbol that names a module or the keyword :device.  The 
;;; current instance of that module
;;; or the current model's device will be passed as the first parameter to 
;;; the action.
;;; priority a number or the keywords :max or :min
;;; params a list of parameters for the action function
;;; details a string describing the event for the trace or nil
;;; output either t or nil 
;;; 
;;; schedule-event creates a new event using the supplied parameters for its 
;;; corresponding attributes and the current model will be used for its model. 
;;; It will then be added to the event queue of the current meta-process.
;;; 
;;; If there are any events waiting to be scheduled they are checked to see
;;; if this new event allows them to be scheduled.
;;; 
;;; If any of the parameters are invalid or there is no current model or 
;;; current meta-process then a warning is printed, no event is scheduled, 
;;; and nil is returned.
;;; 
;;; The scheduled event is returned when successfully created and scheduled.
;;; 
;;; schedule-event-relative
;;; 
;;; (defun schedule-event-relative (time-delay action 
;;;                                 &key (module :none) (destination nil)
;;;                                      (priority 0)(params nil) (details nil)
;;;                                      (output t)))
;;; 
;;; time-delay a time in seconds which should be a non-negative number
;;; action a function or function-name
;;; module a symbol that names the module which is scheduling the event
;;; destination a symbol that names a module or the keyword :device.  The 
;;; current instance of that module
;;; or the current model's device will be passed as the first parameter to 
;;; the action.
;;; priority a number or the keywords :max or :min
;;; params a list of parameters for the action function
;;; details a string describing the event for the trace or nil
;;; output either t or nil 
;;; 
;;; schedule-event-relative creates a new event with a time that is equal 
;;; to the current time plus time-delay and using the other supplied 
;;; parameters for its corresponding attributes and the current model for 
;;; its model which is then added to the event queue of the current 
;;; meta-process.
;;; 
;;; If there are any events waiting to be scheduled they are checked to see 
;;; if this new event allows them to be scheduled.
;;; 
;;; If any of the parameters are invalid or there is no current model or 
;;; current meta-process then a warning is printed, no event is scheduled, 
;;; and nil is returned.
;;; 
;;; The scheduled event is returned when successfully created and scheduled.
;;; 
;;; schedule-event-after-module
;;; 
;;; (defun schedule-event-after-module (after-module action 
;;;                                    &key (module :none) (destination nil)
;;;                                         (priority 0) (params nil) 
;;;                                         (details nil) (output t)
;;;                                         (delay t)))
;;; 
;;; after-module a symbol that names a module
;;; action a function or function-name
;;; module a symbol that names the module which is scheduling the event
;;; destination a symbol that names a module or the keyword :device.  The 
;;; current instance of that module
;;; or the current model's device will be passed as the first parameter to 
;;; the action.
;;; params a list of parameters for the action function
;;; details a string describing the event for the trace or nil
;;; output either t or nil 
;;; delay one of t, nil, or :abort.
;;; 
;;; schedule-event-after-module creates a new event using the supplied 
;;; parameters for its corresponding attributes and the current model for
;;; its model.
;;; 
;;; If there is an event currently in the event queue with the module name 
;;; of after-module and the same model as the current model then this new
;;; event is placed into the event queue at the time of the next such event 
;;; (lowest time) with a priority of :min.  If there are any events waiting 
;;; to be scheduled they are checked to see if this new event allows them to
;;; be scheduled.
;;; 
;;; If there is no event in the event queue that matches on both model and
;;; module then the value of delay determines what happens to the new event.
;;; 
;;; If delay is t then the new event is placed into the set of waiting 
;;; events to be scheduled after an event which matches after-module and 
;;; the current model.
;;; 
;;; If delay is nil then the new event is added to the event queue for 
;;; immediate execution.  Its time will be set to the current time and its
;;; priority will be :max.
;;; 
;;; If delay is :abort then the new event is discarded without being
;;; scheduled or placed onto the waiting queue.
;;; 
;;; schedule-event-after-module returns 2 values.  
;;; 
;;; If there is no current model or current meta-process or any of the
;;; parameters are invalid, then no event is scheduled and both values 
;;; are nil.
;;; 
;;; If an event is scheduled then the first value will be the event and 
;;; the second value will be t if the event is in the waiting queue or nil 
;;; if it is in the event queue.
;;; 
;;; If the event is aborted the first value will be nil and the second 
;;; value will be :abort.
;;;                                  
;;; schedule-event-after-change
;;; 
;;; (defun schedule-event-after-change (action 
;;;                                     &key (module :none) (destination nil)
;;;                                          (params nil) (details nil) 
;;;                                          (output t) (delay t)))
;;; 
;;; 
;;; action a function or function-name
;;; module a symbol that names the module which is scheduling the event
;;; destination a symbol that names a module or the keyword :device.  The 
;;; current instance of that module
;;; or the current model's device will be passed as the first parameter to
;;; the action.
;;; params a list of parameters for the action function
;;; details a string describing the event for the trace or nil
;;; output either t or nil 
;;; delay one of t, nil, or :abort.
;;; 
;;; schedule-event-after-change creates a new event using the supplied 
;;; parameters for its corresponding attributes and the current model for 
;;; its model.
;;; 
;;; If there is any event currently in the event queue with the same model
;;; as the current model then this new event is placed into the event queue 
;;; at the time of the next such event (lowest time) with a priority of :min.
;;; If there are any events waiting to be scheduled they are checked to see 
;;; if this new event allows them to be scheduled.
;;; 
;;; If there is no event in the event queue that matches the current model
;;; then the value of delay determines what happens to the new event.
;;; 
;;; If delay is t then the new event is placed into the set of waiting events 
;;; to be scheduled after an event which matches the current model.
;;; 
;;; If delay is nil then the new event is added to the event queue for
;;; immediate execution.  Its time will be set to the current time and
;;; its priority will be :max.
;;; 
;;; If delay is :abort then the new event is discarded without being scheduled.
;;; 
;;; schedule-event-after-change returns 2 values.  
;;; 
;;; If there is no current model or current meta-process or any of the 
;;; parameters are invalid, then no event is scheduled and both values are nil.
;;; 
;;; If an event is scheduled then the first value will be the event and
;;; the second value will be t if the event is in the waiting queue or 
;;; nil if it is in the event queue.
;;; 
;;; If the event is aborted the first value will be nil and the second 
;;; value will be :abort.
;;; 
;;; schedule-periodic-event
;;; 
;;; (defun schedule-periodic-event (period action 
;;;                                 &key (module :none) (destination nil)
;;;                                      (priority 0) (params nil) 
;;;                                      (details nil) (output t)
;;;                                      (initial-delay 0)))
;;; 
;;; 
;;; period a time in seconds which should be a non-negative number
;;; action a function or function-name
;;; module a symbol that names the module which is scheduling the event
;;; destination a symbol that names a module or the keyword :device.  The 
;;; current instance of that module
;;; or the current model's device will be passed as the first parameter to 
;;; the action.
;;; priority a number or the keywords :max or :min
;;; params a list of parameters for the action function
;;; details a string describing the event for the trace or nil
;;; output either t or nil 
;;; initial-delay a time in seconds which should be a non-negative number
;;; 
;;; schedule-periodic-event creates a new event with a time that is equal 
;;; to the current time plus initial-delay and using the other supplied
;;; parameters for its corresponding attributes and the current model for 
;;; its model which is then added to the event queue of the current
;;; meta-process.  After that event occurs a new event will automatically be
;;; scheduled to occur period seconds after that time with the same parameters
;;; as the initial one.  That rescheduling will continue every period seconds
;;; until the event is deleted.
;;; 
;;; If there are any events waiting to be scheduled they are checked to see
;;; if this new event allows them to be scheduled, and every time that it is 
;;; rescheduled there will be a check of the waiting events.
;;; 
;;; If any of the parameters are invalid or there is no current model or
;;; current meta-process then a warning is printed, no event is scheduled,
;;; and nil is returned.
;;; 
;;; The scheduled event is returned when successfully created and scheduled.
;;; 
;;; schedule-break
;;; 
;;; (defun schedule-break (time &key (priority :max) (details nil)))
;;; 
;;; time a time in seconds which should be a non-negative number
;;; priority a number or the keywords :max or :min
;;; details a string describing the event for the trace or nil
;;; 
;;; schedule-break creates a new break event at the specified time with 
;;; the priority and details provided.  The model of the event will be the
;;; current model and the module is set to :none.  A break event does not
;;; have an action and is only used to stop the scheduler.  That new event
;;; is then added to the event queue of the current meta-process.
;;; 
;;; If any of the parameters are invalid or there is no current model or 
;;; current meta-process then a warning is printed, no event is scheduled, 
;;; and nil is returned.
;;; 
;;; The scheduled event is returned when successfully created and scheduled.
;;; 
;;; schedule-break-relative
;;; 
;;; (defun schedule-break-relative (time-delay 
;;;                                 &key (priority :max) (details nil)))
;;; 
;;; time-delay a time in seconds which should be a non-negative number
;;; priority a number or the keywords :max or :min
;;; details a string describing the event for the trace or nil
;;; 
;;; schedule-break-relative creates a new break event with a time set to the
;;; current time plus the specified time-delay with the priority and details 
;;; provided.  The model of the event will be the current model and the
;;; module is set to :none.  A break event does not have an action and is 
;;; only used to stop the scheduler.  That new event is then added to the 
;;; event queue of the current meta-process.
;;; 
;;; If any of the parameters are invalid or there is no current model or 
;;; current meta-process then a warning is printed, no event is scheduled,
;;; and nil is returned.
;;; 
;;; The scheduled event is returned when successfully created and scheduled.
;;; 
;;; schedule-break-after-module
;;; 
;;; (defun schedule-break-after-module (after-module 
;;;                                     &key (details nil) (delay t)))
;;; 
;;; 
;;; after-module a symbol that names a module
;;; details a string describing the event for the trace or nil
;;; delay one of t, nil, or :abort.
;;; 
;;; schedule-break-after-module creates a break event with the supplied 
;;; details and the current model for its model.
;;; 
;;; If there is an event currently in the event queue with the module name
;;; of after-module and the same model as the current model then this new
;;; event is placed into the event queue at the time of the next such event
;;; (lowest time) with a priority of :min.  
;;; 
;;; If there is no event in the event queue that matches on both model and 
;;; module then the value of delay determines what happens to the new event.
;;; 
;;; If delay is t then the new event is placed into the set of waiting events 
;;; to be scheduled after an event which matches after-module and the 
;;; current model.
;;; 
;;; If delay is nil then the new event is added to the event queue for 
;;; immediate execution.  Its time will be set to the current time and its 
;;; priority will be :max.
;;; 
;;; If delay is :abort then the new event is discarded without being 
;;; scheduled.
;;; 
;;; schedule-break-after-module returns 2 values.  
;;; 
;;; If there is no current model or current meta-process or any of the 
;;; parameters are invalid, then no event is scheduled and both values are 
;;; nil.
;;; 
;;; If an event is scheduled then the first value will be the event and the 
;;; second value will be t if the event is in the waiting queue or nil if 
;;; it is in the event queue.
;;; 
;;; If the event is aborted the first value will be nil and the second value
;;; will be :abort.
;;; 
;;; schedule-break-after-all
;;; 
;;; (defun schedule-break-after-all (&key (details nil)))
;;; 
;;; details a string describing the event for the trace or nil
;;; 
;;; schedule-break-after-all creates a new break event with the provided 
;;; details.  The event's model is set to the current model and the module 
;;; is set to :none.  A break event does not have an action and is only
;;; used to stop the scheduler.  The time for this new event is the greatest
;;; time of any event currently in the event queue of the current meta-process
;;; and its priority is :min.  It will be inserted into the event queue such 
;;; that it will occur after all of the events currently scheduled.
;;; 
;;; If details is invalid or there is no current model or current meta-process
;;; then a warning is printed, no event is scheduled, and nil is returned.
;;; 
;;; The scheduled event is returned when successfully created and scheduled.
;;; 
;;; delete-event
;;; 
;;; (defun delete-event (event))
;;; 
;;; event is an event that was returned by one of the scheduling functions
;;; 
;;; If event is in either the event queue or the waiting queue of the 
;;; current meta-process it is removed.
;;; 
;;; If there is no current meta-process a warning is displayed.
;;; 
;;; If the event is removed from either queue t is returned, otherwise it 
;;; returns nil.
;;; 
;;; 
;;; add-pre-event-hook
;;; 
;;; (defun add-pre-event-hook (hook-fn))
;;; 
;;; hook-fn a function which accepts one parameter or the name of such a 
;;; function
;;; 
;;; hook-fn function is added to the set of functions to be called before 
;;; each event is processed in the current meta-process.  An event that is
;;; about to be processed will be passed to the hook-fn function before it 
;;; is executed by the scheduler.
;;; 
;;; If there is no current meta-process a warning is displayed and nil is 
;;; returned.
;;; If there is a current meta-process, then an id for hook-fn is returned.
;;; 
;;; add-post-event-hook
;;; 
;;; (defun add-post-event-hook (hook-fn))
;;; 
;;; hook-fn a function which accepts one parameter or the name of such a
;;; function
;;; 
;;; hook-fn function is added to the set of functions to be called after 
;;; each event is processed in the current meta-process.  After an event 
;;; is executed it will be passed to the hook-fn function.
;;; 
;;; If there is no current meta-process a warning is displayed and nil is 
;;; returned.
;;; If there is a current meta-process, then an id for hook-fn is returned.
;;; 
;;; delete-event-hook 
;;; 
;;; (defun delete-event-hook (hook-fn-id))
;;; 
;;; hook-fn-id a hook function id that was returned from either 
;;; add-pre-event-hook or add-post-event-hook
;;; 
;;; If the hook function with hook-fn-id is still a member of either set of 
;;; hook functions in the current meta-process then it is removed from the 
;;; set of hook functions.
;;; 
;;; If there is no current meta-process a warning is displayed and nil is
;;; returned.
;;; 
;;; If the hook function with hook-fn-id has already been removed or
;;; hook-fn-id is otherwise invalid nil is returned.
;;; 
;;; It a function is successfully removed then that function (or function name)
;;; is returned.
;;; 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; Design Choices:
;;; 
;;; Keep the system as simple as I can.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 
;;; The code
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#+:packaged-actr (in-package :act-r)
#+(and :clean-actr (not :packaged-actr) :ALLEGRO-IDE) (in-package :cg-user)
#-(or (not :clean-actr) :packaged-actr :ALLEGRO-IDE) (in-package :cl-user)


(defvar *periodic-event-id-counter* 0)

(defun run-sched-queue (mp stop-condition &key (real-time nil))
  "The internal function that steps through events sending them to be
    executed until a condtion is met"
  
  (setf (meta-p-running mp) t)
  
  (unwind-protect 
      (let ((event-count 0)
            (last-update-time -1)
            (toggle nil)) ; can get stuck due to floating point math...
        
        
        (setf (meta-p-start-time mp) (meta-p-time mp))
        (setf (meta-p-start-real-time mp) 
          (funcall (meta-p-time-function mp)))
        
        (setf (meta-p-break mp) nil)
        
        (while (and (not (meta-p-break mp))
                    (meta-p-events mp)
                    (not (funcall stop-condition 
                                  mp 
                                  (evt-time (first (meta-p-events mp)))
                                  event-count)))           
          
          
          
          (if (and (null toggle)
                   (meta-p-max-time-delta mp)
                   (numberp (meta-p-max-time-delta mp))
                   (> (- (evt-time (first (meta-p-events mp)))
                         (meta-p-time mp))
                      (meta-p-max-time-delta mp)))
              
              (progn
                (setf toggle t)
                (dolist (model (mp-models))
                  (with-model-fct model
                    `((schedule-event-relative ,(meta-p-max-time-delta mp) 'dummy-event-function 
                                               :priority :max 
                                               :details 
                                               "A dummy event to prevent model skip ahead"
                                               :output nil)))))
            (progn
              (setf toggle nil)
              (run-one-event mp real-time)
              
              (incf event-count)
              
              ;; Check to see if there needs to be an update 
              
              (unless (or (and (meta-p-events mp)
                               (= (meta-p-time mp) (evt-time (first (meta-p-events mp)))))
                          (= (meta-p-time mp) last-update-time))
                
                (let ((current-model (meta-p-current-model mp)))
                  (unwind-protect 
                      (maphash #'(lambda (model-name model) 
                                   (declare (ignore model-name))
                                   (setf (meta-p-current-model mp) model) 
                                   
                                   (dolist (module (updating-modules))
                                     (update-the-module module last-update-time (meta-p-time mp))))
                               
                               (meta-p-models mp))
                    
                    (setf (meta-p-current-model mp) current-model)))
                
                (setf last-update-time (meta-p-time mp))))))
        
        (setf (meta-p-events mp) (remove 'dummy-event-function (meta-p-events mp)
                                         :key #'evt-action))
        
        (values (- (meta-p-time mp) (meta-p-start-time mp)) event-count 
                (meta-p-break mp)))
    
    (setf (meta-p-running mp) nil)))
    
    
;;; run-one-event 
;;;
;;; This function takes one required parameter which is a meta-process (not
;;; a name of a meta-process).
;;;
;;; The clock is updated, the next event on the meta-process's scheduled events 
;;; queue is removed,  a line is printed to the trace to indicate the event,
;;; and that event's action is executed with  the current model set to the model
;;; specified in that event (even if it doesn't name a model).  If there are 
;;; any event hook functions, they are called with the event as a parameter 
;;; as appropriate (a pre-hook is called before the action and a post-hook is 
;;; called after the action).

(defun run-one-event (mp &optional (real-time nil))
  "Dispatch the next event on the meta-process's schedule"
  (let ((current-model (meta-p-current-model mp)))
    (unwind-protect 
        (let ((next-event nil))
          (set-mp-clock mp (evt-time (car (meta-p-events mp))) real-time)
          
          (setf next-event (pop (meta-p-events mp)))
          
          (when (evt-dynamic next-event)
            (setf (meta-p-dynamics mp) (remove next-event (meta-p-dynamics mp) :key #'car))
            (setf (evt-wait-condition next-event) nil))
          
          (when (evt-model next-event)
            (setf (meta-p-current-model mp) 
              (gethash (evt-model next-event) (meta-p-models mp))))
          
          (dolist (hook (meta-p-pre-events mp))
            (funcall hook next-event))
          
          (when (and (evt-output next-event) 
                     (filter-output-events next-event))
            
            (if (act-r-break-event-p next-event)
                (meta-p-output (format-event next-event))
              (model-output "~a" (format-event next-event))))
          
          (if (evt-destination next-event)
              (apply (evt-action next-event) 
                     (append (list (get-module-fct
                                    (evt-destination next-event))) 
                             (evt-params next-event)))
            (apply (evt-action next-event) (evt-params next-event)))
          
          (dolist (hook (meta-p-post-events mp))
            (funcall hook next-event))
          )
      
      (setf (meta-p-current-model mp) current-model))))

;;; set-mp-clock
;;;
;;; This function takes three parameters which are a meta-process, the next
;;; time as it stands now, and whether or not it's to run in real-time.
;;;
;;; The meta-process's time is updated to the specified time and then if the
;;; meta-process's mp-real-time-p slot is non-nil it spins until the appropriate 
;;; amount of time has passed.
;;;
;;; The spin should probably call sleep, or perhaps a machine specific 
;;; event handler so that it could be swapped out and doesn't swamp the
;;; processor because that could be an issue for multiple models in a real time
;;; environment.

(defun set-mp-clock (mp time real-time)
  "Update the time of a meta-process and maybe spin for the necessary real time"
  
  (setf (meta-p-time mp) time)
                                    
  (when real-time
    
    
    (do ((delta-model (- time (meta-p-start-time mp))
                      (- (evt-time (car (meta-p-events mp))) (meta-p-start-time mp)))
         (delta-real (/ (- (funcall (meta-p-time-function mp))
                           (meta-p-start-real-time mp))
                        (meta-p-units-per-second mp))
                     (/ (- (funcall (meta-p-time-function mp))
                           (meta-p-start-real-time mp))
                        (meta-p-units-per-second mp))))
        ((>= delta-real delta-model))
      (funcall (meta-p-slack-function mp) (- delta-model delta-real)))
    
    (setf (meta-p-time mp) (evt-time (car (meta-p-events mp))))))


(defun real-time-slack (delta)
  (when (> delta .150)
    (sleep delta)))


;;; This function lets all the models know that a run has terminated.

(defun send-run-terminated-events (mp)
  (let ((current-model (meta-p-current-model mp)))
    (unwind-protect 
        (dolist (model-name (hash-table-keys (meta-p-models mp)))
          (push (make-act-r-maintenance-event :time (mp-time)
                                              :priority :max
                                              :action 'run-terminated
                                              :params nil
                                              :model model-name
                                              :mp (current-meta-process)
                                              :output nil
                                              )
                (meta-p-events mp))
          (run-one-event mp))
      
        (setf (meta-p-current-model mp) current-model))))

(defun run-terminated ()
  (when (update-chunks-at-all)
    (normalize-chunk-names (delete-chunks-after-run)))
  nil)



(defun run (run-time &key (real-time nil))
  (verify-current-mp  
   "run called with no current meta-process."
   (if (meta-p-running (current-mp))
       (print-warning "Recursive call to a running function not allowed.  Must wait for a 'run' to complete before 'running' again.")
     (if (not (and (numberp run-time) (> run-time 0)))
         (print-warning "run-time must be a number greater than zero.")
       (flet ((test (mp next-time count)
                    (declare (ignore count))
                    (> (- next-time (meta-p-start-time mp)) run-time)))
         (multiple-value-bind (time events break)
             (run-sched-queue (current-mp) #'test :real-time real-time)
           (unless break
             (send-run-terminated-events (current-mp))
             (if (< time run-time)
                 (if (null (meta-p-events (current-mp)))
                     (meta-p-output (format-event (make-act-r-event 
                                                   :time (mp-time)
                                                   :module "------"
                                                   :model '-
                                                   :details 
                                                   "Stopped because no events left to process"
                                                   :output t
                                                   :mp (current-meta-process))))
                   (progn
                     (run-full-time (- run-time time) :real-time nil)
                     (setf time run-time)))
               (meta-p-output (format-event (make-act-r-event 
                                             :time (mp-time)
                                             :module "------"
                                             :model '-
                                             :details "Stopped because time limit reached"
                                             :output t
                                             :mp (current-meta-process))))
               ))
           (values time events break)))))))

(defun run-until-condition (condition &key (real-time nil))
  (verify-current-mp  
   "run-until-condition called with no current meta-process."
   (if (meta-p-running (current-mp))
       (print-warning "Recursive call to a running function not allowed.  Must wait for a 'run' to complete before 'running' again.")
     (if (not (or (functionp condition) (fboundp condition)))
         (print-warning "condition must be a function.")
       (multiple-value-bind (time events break)
           (run-sched-queue (current-mp) 
                            #'(lambda (mp next-time count)
                                (declare (ignore mp next-time count))
                                (funcall condition))
                            :real-time real-time)
         (unless break
           (send-run-terminated-events (current-mp))
           (if (null (meta-p-events (current-mp)))
               (meta-p-output (format-event (make-act-r-event 
                                             :time (mp-time)
                                             :module "------"
                                             :model '-
                                             :details "Stopped because no events to process"
                                             :output t
                                             :mp (current-meta-process))))
             (meta-p-output (format-event (make-act-r-event 
                                           :time (mp-time)
                                           :module "------"
                                           :model '-
                                           :details "Stopped because condition is true"
                                           :output t
                                           :mp (current-meta-process))))
             ))
         (values time events break))))))

(defun run-full-time (run-time &key (real-time nil))
  (verify-current-mp  
   "run-full-time called with no current meta-process."
   (if (meta-p-running (current-mp))
       (print-warning "Recursive call to a running function not allowed.  Must wait for a 'run' to complete before 'running' again.")
     (if (not (and (numberp run-time) (> run-time 0)))
         (print-warning "run-time must be a number greater than zero.")
       (run-until-time (+ run-time (mp-time)) :real-time real-time)))))


(defun dummy-event-function ()
  )

(defun run-until-time (end-time &key (real-time nil))
  (verify-current-mp  
   "run-until-time called with no current meta-process."
   (if (meta-p-running (current-mp))
       (print-warning "Recursive call to a running function not allowed.  Must wait for a 'run' to complete before 'running' again.")
     (if (not (and (numberp end-time) (> end-time 0)))
         (print-warning "end-time must be a number greater than zero.")
       (progn
         (setf end-time (ms-round end-time))
         (if (<= end-time (mp-time))
             (progn
               (meta-p-output (format-event (make-act-r-event 
                                             :time (mp-time)
                                             :module "------"
                                             :model '-
                                             :details "Stopped because end time already passed"
                                             :output t
                                             :mp (current-meta-process))))
               (values 0 0 nil))
           (flet ((test (mp next-time count)
                        (declare (ignore count) (ignore mp))
                        (> next-time end-time)))
             
             (if (current-model)
                 (schedule-event end-time 'dummy-event-function 
                                 :maintenance t :priority :min 
                                 :details 
                                 "A dummy event to guarantee a run until time"
                                 :output nil)
               (with-model-fct (first (mp-models)) ;; just pick the first one
                 `((schedule-event ,end-time 'dummy-event-function 
                                   :maintenance t 
                                   :priority :min 
                                   :details 
                                   "A dummy event to guarantee a run until time"
                                   :output nil))))
             
             (multiple-value-bind (time events break)
                 (run-sched-queue (current-mp) #'test :real-time real-time)
               (unless break
                 (send-run-terminated-events (current-mp))
                 (meta-p-output (format-event (make-act-r-event 
                                               :time (mp-time)
                                               :module "------"
                                               :model '-
                                               :details "Stopped because time limit reached"
                                               :output t
                                               :mp (current-meta-process)))))
               (values time events break)))))))))


(defun run-n-events (event-count &key (real-time nil))
  (verify-current-mp  
   "run-n-events called with no current meta-process."
   (if (meta-p-running (current-mp))
       (print-warning "Recursive call to a running function not allowed.  Must wait for a 'run' to complete before 'running' again.")
     (if (not (and (numberp event-count) (> event-count 0)))
         (print-warning "event-count must be a number greater than zero.")
       (flet ((test (mp next-time count)
                    (declare (ignore next-time) (ignore mp))
                    (= count event-count)))
         (multiple-value-bind (time events break)
             (run-sched-queue (current-mp) #'test :real-time real-time)
           (unless break
             (send-run-terminated-events (current-mp))
             
             (if (< events event-count)
                 (meta-p-output (format-event (make-act-r-event 
                                               :time (mp-time)
                                               :module "------"
                                               :model '-
                                               :details "Stopped because no events to process"
                                               :output t
                                               :mp (current-meta-process))))   
               (meta-p-output (format-event (make-act-r-event 
                                             :time (mp-time)
                                             :module "------"
                                             :model '-
                                             :details "Stopped because event limit reached"
                                             :output t
                                             :mp (current-meta-process))))))
           (values time events break)))))))




(defun run-step ()
  (verify-current-mp  
   "run-step called with no current meta-process."
   (if (meta-p-running (current-mp))
       (print-warning "Recursive call to a running function not allowed.  Must wait for a 'run' to complete before 'running' again.")
     (flet ((test (mp next-time count)
                  (declare (ignore next-time count))
                  (loop
                    (when (null (meta-p-events mp))
                      (format t "No more events to process")
                      (return t)
                      )
                    (format t "Next Event: ~A~%" 
                      (format-event (car (meta-p-events mp))))
                    (format t "[A]bort (or [q]uit)~%")
                    (format t "[D]elete~%")
                    (format t "[S]how event queue~%")
                    (format t "[W]aiting events~%")
                    (format t "[B]uffer contents~%")
                    (format t "[E]xecute~%")
                    
                    (let ((response (read )))
                      (case response
                        ((a q) (return t))
                        (e (return nil))
                        (s (mp-show-queue))
                        (w (mp-show-waiting))
                        (b (show-buffer-chunks))
                        (d (pop (meta-p-events mp)))
                        )))))
       
       
       (multiple-value-bind (time events break)
           (run-sched-queue (current-mp) #'test :real-time nil)
         (unless break
           (send-run-terminated-events (current-mp))
           (meta-p-output (format-event (make-act-r-event 
                                         :time (mp-time)
                                         :module "------"
                                         :model '-
                                         :details "Stepping stopped"
                                         :output t
                                         :mp (current-meta-process)))))
         (values time events break))))))

(defun schedule-event (time action 
                            &key (maintenance nil)
                            (module :none) (destination nil)
                            (priority 0) (params nil) 
                            (details nil) (output t))
  (verify-current-mp  
   "schedule-event called with no current meta-process."
   (verify-current-model
    "schedule-event called with no current model."
    (let ((mp (current-mp)))
      (cond ((not (and (numberp time) (>= time 0)))
             (print-warning "Time must be non-negative number."))
            ((not (or (functionp action) (fboundp action)))
             (print-warning "Can't schedule ~S not a function or function name."
                            action))
            ((not (or (numberp priority) (eq priority :min) (eq priority :max)))
             (print-warning "Priority must be a number or :min or :max."))
            ((not (listp params))
             (print-warning "params must be a list."))
            (t
             (let ((new-event (funcall (if maintenance
                                           #'make-act-r-maintenance-event
                                         #'make-act-r-event) 
                                       :mp (meta-p-name mp)
                                       :model (current-model)
                                       :module module
                                       :time (ms-round time)
                                       :priority priority
                                       :action action
                                       :params params
                                       :details details
                                       :output output
                                       :destination destination)))
               
               (insert-queue-event mp new-event)
               
               (when (or (meta-p-delayed mp) (meta-p-dynamics mp))
                 (update-waiting-events mp new-event))
               
               new-event)))))))


(defun schedule-maintenance-event (time action 
                                        &key (module :none) (destination nil)
                                        (priority 0) (params nil) 
                                        (details nil) (output t))
  (print-warning "The schedule-maintenance functions no longer exist.")
  (print-warning "Instead there is now a maintenance keyword accepted by the regular schedule-* functions."))


;;; insert-queue-event
;;;
;;; This function takes two parameter which are a meta-process and an
;;; event.  The event is added to the list of scheduled events for the
;;; meta-process in order based on its time and priority.
;;;
;;; Items are ordered by time first, lower times occuring before higher
;;; times.  If two events have the same time then:
;;;
;;; An event with priority :max occurs before any event in the queue with
;;;                             the same time except existing events of :max
;;;                             priority
;;; An event with a numeric priority occurs before an event with a lesser
;;;                             numbered priority or a priority of :min
;;; An event with priority :min occurs after any events at that time
;;;

(defun insert-queue-event (mp event)
  "Place an event into the scheduled-events list maintaing the ordering"
  (if (null (meta-p-events mp))
      (push event (meta-p-events mp))
    
    
    (setf (meta-p-events mp)
      (do* ((pos 0 (1+ pos))
            (queue (meta-p-events mp) (cdr queue)))
           ((or (null queue)
                (eq :left (compare-events event (car queue))))
            (splice-into-list-des (meta-p-events mp) pos event))))))


(defun compare-events (new-event old-event)
  (if (or (> (evt-time new-event) (evt-time old-event))
          (and (= (evt-time new-event) (evt-time old-event))
               (or (eq (evt-priority new-event) :min)
                   (eq (evt-priority old-event) :max)
                   (and (numberp (evt-priority new-event))
                        (numberp (evt-priority old-event))
                        (<= (evt-priority new-event) 
                            (evt-priority old-event))))))
      
      :right :left))

;;; update-waiting-events
;;;
;;; This function takes two parameters, a meta-process and an event.  The 
;;; list of waiting events for the meta-process is checked to see if the
;;; event specified allows any of them to be added to the scheduled events.
;;; If an event can be moved to the scheduled events list it is removed
;;; from the waiting events list and it is added to the scheduled events
;;; list (which will call update-waiting-events to test whether that event
;;; frees others from the waiting list).
;;; The list of dynamic events is also tested in the same way as the
;;; waiting events.

(defun update-waiting-events (mp new-event)
  "Check the list of waiting events to see if a new event allows any to run"
  (let ((moved-events nil))
    (dolist (event (meta-p-delayed mp))
      (when (conditions-met event new-event)
        (setf (meta-p-delayed mp) (remove event (meta-p-delayed mp)))
        (unless (evt-dynamic event)
          (setf (evt-wait-condition event) nil))
        (push event moved-events)))
    
    (dolist (event-check (meta-p-dynamics mp))
      (let ((event (car event-check))
            (cur-time (cdr event-check)))
        (when (and (< (evt-time new-event) cur-time)
                   (conditions-met event new-event))
          (delete-event event)
          (push event moved-events))))
    
    (dolist (event moved-events)
      (let ((n-event
             (if (act-r-break-event-p event)
                 (schedule-break (evt-time new-event)
                                 :priority :min
                                 :details (evt-details event))
               (schedule-event  (evt-time new-event)
                               (evt-action event)
                               :module (evt-module event)
                               :details (evt-details event)
                               :params (evt-params event)
                               :priority :min
                               :output (evt-output event) 
                               :destination (evt-destination event)
                               :maintenance (act-r-maintenance-event-p event)))))
        (when (evt-dynamic event)
          (setf (evt-dynamic n-event) t)
          (setf (evt-wait-condition n-event) (evt-wait-condition event))
          (push (cons n-event (evt-time new-event)) (meta-p-dynamics mp)))))))

;;; conditions-met
;;;
;;; This function takes two parameters which are a waiting-event and a
;;; new-event.  

(defun conditions-met (w-event new-event)
  "Test whether a waiting event's wait-for reason is met by a new event"
  (case (car (evt-wait-condition w-event))
    (:any (and (eq (evt-model w-event) (evt-model new-event))
               (or (second (evt-wait-condition w-event))
                   (not (act-r-maintenance-event-p new-event)))))
    
    (:module (and (or (eq (evt-model w-event) (evt-model new-event))
                      (null (evt-model w-event)))
                  (eq (second (evt-wait-condition w-event)) 
                      (evt-module new-event))
                  (or (third (evt-wait-condition w-event))
                   (not (act-r-maintenance-event-p new-event)))))
    (t nil)))
  
  

(defun schedule-event-relative (time-delay action 
                                           &key (maintenance nil)
                                           (module :none) (destination nil)
                                           (priority 0) (params nil) 
                                           (details nil) (output t))
  (verify-current-mp  
   "schedule-event-relative called with no current meta-process."
   (verify-current-model
    "schedule-event-relative called with no current model."
    (let ((mp (current-mp)))
      (cond ((not (and (numberp time-delay) (>= time-delay 0)))
             (print-warning "Time-delay must be non-negative number."))
            ((not (or (functionp action) (fboundp action)))
             (print-warning 
              "Can't schedule ~S not a function or function name."
                            action))
            ((not (or (numberp priority) (eq priority :min) (eq priority :max)))
             (print-warning "Priority must be a number or :min or :max."))
            ((not (listp params))
             (print-warning "params must be a list."))
            (t
             (let ((new-event 
                    (funcall (if maintenance
                                 #'make-act-r-maintenance-event
                               #'make-act-r-event)
                             :mp (meta-p-name mp)
                             :model (current-model) 
                             :module module
                             :time (ms-round (+ (meta-p-time mp) 
                                                time-delay))
                             :priority priority
                             :action action
                             :params params
                             :details details
                             :output output
                             :destination destination)))
               
               (insert-queue-event mp new-event)
               
               (when (or (meta-p-delayed mp) (meta-p-dynamics mp))
                 (update-waiting-events mp new-event))
               
               new-event)))))))


(defun schedule-maintenance-event-relative (time-delay action 
                                                       &key (module :none) (destination nil)
                                                       (priority 0) (params nil) 
                                                       (details nil) (output t))
  (print-warning "The schedule-maintenance functions no longer exist.")
  (print-warning "Instead there is now a maintenance keyword accepted by the regular schedule-* functions."))





(defun schedule-event-after-module (after-module action 
                                                 &key (maintenance nil)
                                                 (module :none) (destination nil)
                                                 (params nil) (details nil) 
                                                 (output t) (delay t)
                                                 (include-maintenance nil)
                                                 (dynamic nil))
  (let ((first-val
         (verify-current-mp  
          "schedule-event-after-module called with no current meta-process."
          (verify-current-model
           "schedule-event-after-module called with no current model."
           (let ((mp (current-mp)))
             (cond ((not (valid-module-name after-module))
                    (print-warning "after-module must name a module."))
                   ((not (or (functionp action) (fboundp action)))
                    (print-warning 
                     "Can't schedule ~S not a function or function name."
                            action))
                   ((not (listp params))
                    (print-warning "params must be a list."))
                   (t
                    (let* ((new-event 
                            (funcall (if maintenance
                                         #'make-act-r-maintenance-event
                                       #'make-act-r-event)
                                     :mp (meta-p-name mp)
                                     :model (current-model) 
                                     :module module
                                     :priority :min
                                     :action action
                                     :params params
                                     :details details
                                     :output output
                                     :destination destination
                                     :dynamic (and dynamic (meta-p-allow-dynamics mp))
                                     :wait-condition 
                                     (list :module after-module 
                                           include-maintenance)))
                           (matching-event 
                            (find-if #'(lambda (x)
                                         (conditions-met new-event x))
                                     (meta-p-events mp))))
                      (cond (matching-event 
                             (setf (evt-time new-event) 
                               (evt-time matching-event))
                             
                             
                             (unless (evt-dynamic new-event)
                               (setf (evt-wait-condition new-event) nil))
                             
                             (when (evt-dynamic new-event)
                               (push (cons new-event (evt-time new-event)) (meta-p-dynamics mp)))
                             
                             (insert-queue-event mp new-event)
                             
                             (when (or (meta-p-delayed mp) (meta-p-dynamics mp))
                               (update-waiting-events mp new-event))
                                                          
                             new-event)
                            ((null delay)
                             (setf (evt-time new-event) (meta-p-time mp))
                             (setf (evt-priority new-event) :max)
                             (setf (evt-wait-condition new-event) nil)
                             (setf (evt-dynamic new-event) nil)
                             
                             (insert-queue-event mp new-event)
                             
                             (when (or (meta-p-delayed mp) (meta-p-dynamics mp))
                               (update-waiting-events mp new-event))
                             
                             new-event)
                            ((eq delay :abort)
                             :abort)
                            (t
                             (push new-event (meta-p-delayed mp))
                             new-event))))))))))
    (if first-val
        (if (act-r-event-p first-val)
            (values first-val (if (evt-wait-condition first-val) t nil))
          (values nil :abort))
      (values nil nil))))
                             

(defun schedule-event-after-change (action 
                                    &key (maintenance nil)
                                    (module :none) (destination nil)
                                    (params nil) (details nil) 
                                    (output t) (delay t)
                                    (include-maintenance nil)
                                    (dynamic nil))

  (let ((first-val
         (verify-current-mp  
          "schedule-event-after-change called with no current meta-process."
          (verify-current-model
           "schedule-event-after-change called with no current model."
           (let ((mp (current-mp)))
             (cond ((not (or (functionp action) (fboundp action)))
                    (print-warning 
                     "Can't schedule ~S not a function or function name."
                     action))
                   ((not (listp params))
                    (print-warning "params must be a list."))
                   (t
                    (let* ((new-event 
                            (funcall (if maintenance
                                         #'make-act-r-maintenance-event
                                       #'make-act-r-event)
                                     :mp (meta-p-name mp)
                                     :model (current-model) 
                                     :module module
                                     :priority :min
                                     :action action
                                     :params params
                                     :details details
                                     :output output
                                     :destination destination
                                     :dynamic (and dynamic (meta-p-allow-dynamics mp))
                                     :wait-condition (list :any include-maintenance)))
                           (matching-event 
                            (find-if #'(lambda (x)
                                         (conditions-met new-event x))
                                     (meta-p-events mp))))
                      (cond (matching-event 
                             (setf (evt-time new-event) 
                               (evt-time matching-event))
                             
                             (unless (evt-dynamic new-event)
                               (setf (evt-wait-condition new-event) nil))
                             
                             (when (evt-dynamic new-event)
                               (push (cons new-event (evt-time new-event)) (meta-p-dynamics mp)))
                                    
                             (insert-queue-event mp new-event)
                             
                             (when (or (meta-p-delayed mp) (meta-p-dynamics mp))
                               (update-waiting-events mp new-event))
                             
                             new-event)
                            ((null delay)
                             (setf (evt-time new-event) (meta-p-time mp))
                             (setf (evt-priority new-event) :max)
                             (setf (evt-wait-condition new-event) nil)
                             (setf (evt-dynamic new-event) nil)
                             
                             (insert-queue-event mp new-event)
                             
                             (when (or (meta-p-delayed mp) (meta-p-dynamics mp))
                               (update-waiting-events mp new-event))
                                                          
                             new-event)
                            ((eq delay :abort)
                             :abort)
                            (t
                             (push new-event (meta-p-delayed mp))
                             new-event))))))))))
    (if first-val
        (if (act-r-event-p first-val)
            (values first-val (if (evt-wait-condition first-val) t nil))
          (values nil :abort))
      (values nil nil))))




(defun schedule-periodic-event (period action 
                                       &key (maintenance nil)
                                       (module :none) (destination nil)
                                       (priority 0) (params nil) 
                                       (details nil) (output t)
                                       (initial-delay 0))
  
  (verify-current-mp  
   "schedule-periodic-event called with no current meta-process."
   (verify-current-model
    "schedule-event called with no current model."
    (let ((mp (current-mp)))
      (cond ((not (and (numberp period) (> period 0)))
             (print-warning "period must be greater than 0."))
            ((not (and (numberp initial-delay) (>= initial-delay 0)))
             (print-warning "initial-dealy must be a non-negative number."))
            ((not (or (functionp action) (fboundp action)))
             (print-warning 
              "Can't schedule ~S not a function or function name."
              action))
            ((not (or (numberp priority) (eq priority :min) (eq priority :max)))
             (print-warning "Priority must be a number or :min or :max."))
            ((not (listp params))
             (print-warning "params must be a list."))
            (t
             (let* ((real-event (funcall (if maintenance
                                             #'make-act-r-maintenance-event
                                           #'make-act-r-event) 
                                         :mp (meta-p-name mp)
                                         :model (current-model) 
                                         :module module
                                         :priority :max
                                         :action action
                                         :params params
                                         :details details
                                         :output output
                                         :destination destination))
                    (id (incf *periodic-event-id-counter*))
                    (periodic-event 
                     (make-act-r-periodic-event 
                      :id id
                      :mp (meta-p-name mp)
                      :module :none
                      :model (current-model) 
                      :time (ms-round (+ (meta-p-time mp) initial-delay)) 
                      :priority priority
                      :action 'periodic-action
                      :params 
                      (list id real-event period 
                            priority)
                      :output nil
                      :details 
                      ;(format nil 
                      ;    "Periodic Action: ~A Period: ~A" action period)
                      (concatenate 'string
                        "Periodic-Action "
                        (if (and (symbolp action) (fboundp action)) (symbol-name action) "Unnamed function")
                        " "
                        (princ-to-string period))
                      )))
               
               (insert-queue-event mp periodic-event)
               
               (when (or (meta-p-delayed mp) (meta-p-dynamics mp))
                 (update-waiting-events mp periodic-event))
               
               periodic-event)))))))


(defun periodic-action (id event period priority)
  (let* ((mp (current-mp))
         (periodic-event 
          (make-act-r-periodic-event 
           :id id
           :mp (evt-mp event)
           :model (evt-model event) 
           :module :none
           :time (ms-round (+ (meta-p-time mp) period)) 
           :priority priority
           :action 'periodic-action
           :params (list id event period priority)
           :output nil
           :details 
           ;(format nil 
           ;    "Periodic Action: ~A Period: ~A" (evt-action event) period)
           (concatenate 'string
                        "Periodic-Action "
                        (princ-to-string (evt-action event))
                        " "
                        (princ-to-string period)))))
    
    (setf (evt-time event) (meta-p-time mp))
    
    (insert-queue-event mp event)
    
    (when (or (meta-p-delayed mp) (meta-p-dynamics mp))
      (update-waiting-events mp event))
    
    (insert-queue-event mp periodic-event)
    
    (when (or (meta-p-delayed mp) (meta-p-dynamics mp))
      (update-waiting-events mp periodic-event))))
    
  
(defun schedule-break (time &key (priority :max) (details nil))
  (verify-current-mp  
   "schedule-break called with no current meta-process."
   (let ((mp (current-mp)))
     (cond ((not (and (numberp time) (>= time 0)))
            (print-warning "Time must be non-negative number."))
           ((not (or (numberp priority) (eq priority :min) (eq priority :max)))
            (print-warning "Priority must be a number or :min or :max."))
           (t
            (let ((new-event (make-act-r-break-event :mp (meta-p-name mp)
                                                     :time (ms-round time)
                                                     :params (list mp)
                                                     :priority priority
                                                     :details details)))
               
               (insert-queue-event mp new-event)
              
              (when (or (meta-p-delayed mp) (meta-p-dynamics mp))
                (update-waiting-events mp new-event))
              
              new-event))))))


(defun schedule-break-relative (time-delay 
                                &key (priority :max) (details nil))
  (verify-current-mp  
   "schedule-break-relative called with no current meta-process."
   (let ((mp (current-mp)))
     (cond ((not (and (numberp time-delay) (>= time-delay 0)))
            (print-warning "Time-delay must be non-negative number."))
           ((not (or (numberp priority) (eq priority :min) (eq priority :max)))
            (print-warning "Priority must be a number or :min or :max."))
           (t
            (let ((new-event (make-act-r-break-event 
                              :mp (meta-p-name mp)
                              :time (ms-round (+ (meta-p-time mp) time-delay))
                              :params (list mp)
                              :priority priority
                              :details details)))
               
               (insert-queue-event mp new-event)
              
              (when (or (meta-p-delayed mp) (meta-p-dynamics mp))
                (update-waiting-events mp new-event))
              
              new-event))))))

(defun schedule-break-after-module (after-module 
                                    &key (details nil) (delay t)(dynamic nil))
  
  (let ((first-val
         (verify-current-mp  
          "schedule-break-after-module called with no current meta-process."
          (verify-current-model
           "schedule-break-after-module called with no current model."
           (let ((mp (current-mp)))
             (cond ((not (valid-module-name after-module))
                    (print-warning "after-module must name a module."))
                   (t
                    (let* ((new-event (make-act-r-break-event 
                                       :mp (meta-p-name mp)
                                       :model (current-model)
                                       :priority :min
                                       :params (list mp)
                                       :details details
                                       :dynamic (and dynamic (meta-p-allow-dynamics mp))
                                       :wait-condition 
                                       (list :module after-module t)))
                           (matching-event 
                            (find-if #'(lambda (x)
                                         (conditions-met new-event x))
                                     (meta-p-events mp))))
                      (cond (matching-event 
                             (setf (evt-time new-event) 
                               (evt-time matching-event))
                             
                             (unless (evt-dynamic new-event)
                               (setf (evt-wait-condition new-event) nil))
                             
                             (when (evt-dynamic new-event)
                               (push (cons new-event (evt-time new-event)) (meta-p-dynamics mp)))
                                                          
                             (insert-queue-event mp new-event)
                             
                             (when (or (meta-p-delayed mp) (meta-p-dynamics mp))
                               (update-waiting-events mp new-event))
                             new-event)
                            ((null delay)
                             (setf (evt-time new-event) (meta-p-time mp))
                             (setf (evt-priority new-event) :max)
                             (setf (evt-wait-condition new-event) nil)
                             (setf (evt-dynamic new-event) nil)
                             
                             (insert-queue-event mp new-event)
                             
                             (when (or (meta-p-delayed mp) (meta-p-dynamics mp))
                               (update-waiting-events mp new-event))
                             new-event)
                            ((eq delay :abort)
                             :abort)
                            (t
                             (push new-event (meta-p-delayed mp))
                             new-event))))))))))
        (if first-val
            (if (act-r-event-p first-val)
                (values first-val (if (evt-wait-condition first-val) t nil))
              (values nil :abort))
          (values nil nil))))
  


(defun schedule-break-after-all (&key (details nil))
  (verify-current-mp  
   "schedule-break called with no current meta-process."
   (let* ((mp (current-mp))
          (new-event (make-act-r-break-event :mp (meta-p-name mp)
                                             :params (list mp)
                                             :priority :min
                                             :details details)))
     
     
     (setf (evt-time new-event) (if (meta-p-events mp)
                                    (evt-time (car (last (meta-p-events mp))))
                                  (meta-p-time mp)))
     
     (insert-queue-event mp new-event)
          
     (when (or (meta-p-delayed mp) (meta-p-dynamics mp))
       (update-waiting-events mp new-event))
     
     new-event)))

(defmethod delete-event ((event t))
  (print-warning "~S is not a valid event." event))


(defmethod delete-event ((event act-r-event))
  (verify-current-mp  
   "delete-event called with no current meta-process."
   (let ((mp (current-mp)))
     
     (cond ((find event (meta-p-events mp))
            (setf (meta-p-events mp) (remove event (meta-p-events mp)))
            (when (evt-dynamic event)
              (setf (meta-p-dynamics mp) (remove event (meta-p-dynamics mp) :key #'car)))
            t)
           ((find event (meta-p-delayed mp))
            (setf (meta-p-delayed mp) (remove event (meta-p-delayed mp)))
            t)
           (t
            nil)))))


;; A periodic event can't be dynamic so don't worry about adding that
;; here...

(defmethod delete-event ((event act-r-periodic-event))
  (verify-current-mp  
   "delete-event called with no current meta-process."
   (let* ((mp (current-mp))
          (events (find (act-r-periodic-event-id event) 
                        (meta-p-events mp) 
                        :key #'(lambda (x) 
                                 (and (eq (type-of x) 'act-r-periodic-event)
                                      (act-r-periodic-event-id x)))))
          (waiting (find (act-r-periodic-event-id event) 
                         (meta-p-delayed mp) 
                         :key #'(lambda (x) 
                                  (and (eq (type-of x) 'act-r-periodic-event)
                                       (act-r-periodic-event-id x))))))
     
     (cond (events
            (setf (meta-p-events mp) 
              (remove (act-r-periodic-event-id event) 
                      (meta-p-events mp) 
                      :key #'(lambda (x) 
                               (and (eq (type-of x) 'act-r-periodic-event)
                                    (act-r-periodic-event-id x)))))
            t)
           (waiting 
            (setf (meta-p-delayed mp) 
              (remove (act-r-periodic-event-id event) 
                      (meta-p-delayed mp) 
                      :key #'(lambda (x) 
                               (and (eq (type-of x) 'act-r-periodic-event)
                                    (act-r-periodic-event-id x)))))
            t)
           (t
            nil)))))
    

(defun add-pre-event-hook (hook-fn &optional (warn t))
  (verify-current-mp
   "add-pre-event-hook called with no current meta-process"
   (let ((mp (current-mp)))
     (cond ((not (or (functionp hook-fn) (fboundp hook-fn)))
            (print-warning 
             "parameter ~s to add-pre-event-hook is not a function" hook-fn))
           ((member hook-fn (meta-p-pre-events mp))
            (when warn
              (print-warning 
               "~s is already on the pre-event-hook list not added again"
               hook-fn)))
           (t (push hook-fn (meta-p-pre-events mp))
              (setf (gethash (meta-p-next-hook-id mp) (meta-p-hook-table mp))
                (cons :pre hook-fn))
              (1- (incf (meta-p-next-hook-id mp))))))))
         
         

(defun add-post-event-hook (hook-fn &optional (warn t))
  (verify-current-mp
   "add-post-event-hook called with no current meta-process"
   (let ((mp (current-mp)))
     (cond ((not (or (functionp hook-fn) (fboundp hook-fn)))
            (print-warning 
             "parameter ~s to add-post-event-hook is not a function" hook-fn))
           ((member hook-fn (meta-p-post-events mp))
            (when warn
              (print-warning 
               "~s is already on the post-event-hook list not added again" 
               hook-fn)))
           (t (push hook-fn (meta-p-post-events mp))
              (setf (gethash (meta-p-next-hook-id mp) (meta-p-hook-table mp))
                (cons :post hook-fn))
              (1- (incf (meta-p-next-hook-id mp))))))))


(defun delete-event-hook (hook-fn-id)
  (verify-current-mp
   "delete-event-hook called with no current meta-process"
   (let* ((mp (current-mp))
          (event (gethash hook-fn-id (meta-p-hook-table mp))))
     (when event
       (remhash hook-fn-id (meta-p-hook-table mp))
       (if (eq :pre (car event))
           (setf (meta-p-pre-events mp) 
             (remove (cdr event) (meta-p-pre-events mp)))
         (setf (meta-p-post-events mp) 
             (remove (cdr event) (meta-p-post-events mp))))
       (cdr event)))))


#|
This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
|#
