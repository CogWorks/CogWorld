;;;  -*- mode: LISP; Syntax: COMMON-LISP;  Base: 10 -*-
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 
;;; Author      : Dan Bothell
;;; Copyright   : (c) 2004-2007 Dan Bothell
;;; Availability: Covered by the GNU LGPL, see LGPL.txt
;;; Address     : Department of Psychology 
;;;             : Carnegie Mellon University
;;;             : Pittsburgh, PA 15213-3890
;;;             : db30@andrew.cmu.edu
;;; 
;;; 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 
;;; Filename    : production-compilation.lisp
;;; Version     : 1.3
;;; 
;;; Description : First pass at production compilation in ACT-R 6.
;;; 
;;; Bugs        : 
;;;
;;; To do       : [ ] Consider the handling of !safe-bind! in respect to doing
;;;             :     a direct substitution with the instantiated binding.
;;;             : [ ] With the addition of the compilation-instan parameter
;;;             :     it may be possible to put the goal style slot remapping
;;;             :     back into the goal mapping function instead of directly
;;;             :     in the composition function, and then remove the clean-up
;;;             :     hack at the end.  Not entirely sure, but definitely worth
;;;             :     investigating at some point.
;;; ----- History -----
;;; 2005.04.26 Dan
;;;             : * Initial creation.
;;;
;;; 2005.05.18 Dan
;;;             : * Works to compose now, but doesn't yet have the parameter
;;;             :   learning pieces.
;;; 2005.05.19 Dan
;;;             : * Note that productions generated by compilation are 
;;;             :   created with p* because p*'s are a super set of p's
;;;             :   and that way p*'s can go through compilation without 
;;;             :   any special handling!
;;;             : * Fixed a bug in the composing functions because if a
;;;             :   buffer isn't mentioned in the first production it doesn't
;;;             :   actually have an index of 0.
;;;             : * Added the utility equation pieces, so it should be "fully"
;;;             :   operational (noting that it isn't defined if parameter
;;;             :   learning is set to use a decay value).
;;; 2005.05.20 Dan
;;;             : * Adding the threshold-time parameter.
;;; 2005.05.24 Dan
;;;             : * Some general clean up for speed and ease of reading for
;;;             :   the newly formed productions.
;;; 2005.05.25 Dan
;;;             : * Fixed an issue in compose-productions where ACL was letting
;;;             :   me get away with some sloppy code.
;;; 2005.05.26 Dan
;;;             : * Some more minor clean up for ease of reading the
;;;             :   the new productions - take out all = slot modifiers and
;;;             :   order the conditions as buffer tests, buffer queries, and
;;;             :   then !'s with the tests and queries in alphabetical order
;;;             :   by buffer name.
;;; 2005.05.27 Dan
;;;             : * Make sure that the compilation is disabled on a reset.
;;;             : * Added the initial-successes, initial-failures, and initial-
;;;             :   efforts parameters.
;;; 2005.06.01 Dan
;;;             : * Fixed a bug in compilation under MCL buffer-condition-
;;;             :   union was trying to set the second of something that was
;;;             :   nil which isn't a good idea, but didn't break in ACL though
;;;             :   I don't know why.
;;;             : * Ammended the tests for a valid production to include not 
;;;             :   having any direct requests and not using any slot modifiers
;;;             :   other than = for now.
;;; 2005.06.02 Dan
;;;             : * Some minor updates. 
;;;             : * Need to check that production name isn't already used 
;;;             :   explicitly since new-name only checks chunk names.
;;;             : * The test for slot modifiers needs to not look at evals and
;;;             :   binds because they may have similar structure...
;;; 2005.06.06 Dan
;;;             : * Fixed a bug in buffer-condition-union because it could be
;;;             :   the case that the first condition is blank and thus one
;;;             :   can't delete the isa from the second in that case.
;;; 2005.06.08 Dan
;;;             : * Changed define-chunk-spec-fct to define-variable-chunk-
;;;             :   spec-fct in produce-standard-representation because 
;;;             :   otherwise it blocks p*'s from being composed.  Since the
;;;             :   chunk-spec wasn't being use other than to order the
;;;             :   production components it shouldn't create any problems...
;;; 2005.06.16 Dan
;;;             ; * Fixed a bug in compose-productions with respect to
;;;             :   !safe-bind! because it wasn't properly copying all the
;;;             :   necessary pieces into the newly composed production.
;;;             : * Changed compose-productions so that it correctly orders
;;;             :   RHS safe-binds because the p2 bindings may depend on the
;;;             :   bindings of p1.  It also now checks to make sure that a
;;;             :   new production gets created without error to revent it 
;;;             :   from just crashing if that happens for some reason.
;;; 2005.08.15 Dan
;;;             : * Fixed a bug in that the hooks weren't removed if epl was
;;;             :   toggled from t to nil.  Thus, prior to this fix the only
;;;             :   way to disable was a reset once it was enabled.
;;; 2005.08.16 Dan
;;;             : * Fixed problems with the handling of !safe-bind! on the RHS.
;;;             :   The issues were if the substitution resulted in the var
;;;             :   being bound mapping onto a constant or if the var being
;;;             :   bound ends up on the LHS of the composed production after
;;;             :   mapping.  The solution (for now) is to convert those to
;;;             :   LHS !safe-eval! tests on the value in question instead.
;;;             : - Another potential solution is to treat !safe-bind! actions
;;;             :   like retrievals and just do the constant substitution with
;;;             :   the instantiated value.
;;;             : * Another situation with binds popped up - a RHS bind + a
;;;             :   LHS eval can result in an odd combination with an unbound
;;;             :   variable, so to fix that there's currently a fix to move
;;;             :   the bind to the LHS.  That then makes the new production
;;;             :   a dead end for compilation, but doesn't cause the system
;;;             :   to crash.
;;; 2005.08.17 Dan
;;;             : * Major change in how !safe-bind! is handled!
;;;             :   Now, instead of trying to catch all the gotchas, a RHS
;;;             :   binding in the first production will be treated like a
;;;             :   retrieval for substitution - the explicit value bound
;;;             :   in the instantiation will be propigated forward into the
;;;             :   new production and the form that was evaluated will be
;;;             :   discarded.
;;;             :   That means that there should be no side effects in the
;;;             :   evaluation of a !safe-bind! because they will not be
;;;             :   carried over to a compiled production!
;;; 2005.08.19 Dan
;;;             : * Continuing to update how binds work.  Not only will the
;;;             :   value of the bound variable be captured, but all variables
;;;             :   that are referenced in the bind expression will be replaced
;;;             :   with their instantiated values from the first production.
;;; 2005.08.22 Dan
;;;             : * More work on the mechanism.  Now, adding a (somewhat)
;;;             :   redundant check to make sure productions are compatible.
;;;             :   This check ensures that a buffer doesn't violate the
;;;             :   assumptions that underlie the style - for instance that
;;;             :   the goal chunk doesn't change other than through a
;;;             :   production.
;;;             :   Right now it's only a check of goal style buffers because
;;;             :   we want partial matching (which may be inconsistent) for
;;;             :   retrieval style buffers and motor and perceptual buffers
;;;             :   don't compile across modifications or requests to begin
;;;             :   with.  This needs to be made more general though so that
;;;             :   it also can be user extended.
;;; 2005.09.01 Dan
;;;             : * Added a call to with-unchecked-p* around the generation of
;;;             :   the new production to allow non-variable new slot creation
;;;             :   (which could happen after substitution in a generated
;;;             :   production).
;;; 2005.09.02 Dan
;;;             : * Patch work to fix issues with p* in general that were
;;;             :   uncovered while testing the slot creation code.
;;;             :   Main issue is that modifications in the first production
;;;             :   need to have the slot names instantiated so that all the
;;;             :   conditions of the second that were set by the first can
;;;             :   be detected.
;;;             : * Since only goal style modules allow buffer modification,
;;;             :   that's where I've applied the fix, but if other styles are
;;;             :   to allow mods then that will have to be handled there too.
;;; 2005.11.09 Dan
;;;             : * Fix for a problem in composing a p1 that makes a retrieval
;;;             :   request with a p2 that doesn't mention retrieval at all.
;;;             :   The request was being dropped, but shouldn't have been.
;;; 2005.12.12 Dan
;;;             : * Temporary fix to composing p* variablized slots (instead of
;;;             :   just instantiating them).  This is a hack John put in and
;;;             :   I'm working on making it more general.
;;; 2005.12.14 Dan
;;;             : * Moved the fix into the goal-style buffers explicitly since
;;;             :   they're the only ones where it's an issue because none of
;;;             :   the other styles allow for a RHS modification.
;;; 2005.12.15 Dan
;;;             : * Realized that I can't do it in the goal buffer processing
;;;             :   because the "normal" variable mapping process needs the
;;;             :   change before it progresses (which occurs before it goes
;;;             :   to the buffer specific code).  So, it's in the main 
;;;             :   function and conditionalized to only occur for the special
;;;             :   case necessary (goal style buffer with a RHS modification).
;;; 2005.12.20 Dan
;;;             : * Minor changes to clean up some compiler warnings.
;;; 2006.01.17 Dan
;;;             : * Time to change the version number and module info text.
;;;             :   It's now version 1.0.
;;; 2006.02.03 Dan
;;;             : * Another issue with p*'s that I don't really have a good
;;;             :   handle on at this point (see pstar-test8.lisp in the test-
;;;             :   models folder for an example).  So, for now I've taken the
;;;             :   easiest approach and just clean-up after the fact.  Which
;;;             :   might be a good idea in general, but doesn't feel quite
;;;             :   right...
;;; 2006.02.07 Dan
;;;             : * Make sure that the RHS !safe-bind! calls in p2 come before the
;;;             :   !safe-eval! and !output! calls in p3 to avoid issues with
;;;             :   unbound vars.  Maintaining original order might be a nice
;;;             :   thing to have, but the "standard rep" loses that at this 
;;;             :   point to allow for better comparisons.  So, if that's really
;;;             :   necessary it'll require some more extensive changes.
;;; 2006.03.10 Dan
;;;             : * Fixed calls to get-production because it no longer requires
;;;             :   the procedural module as a parameter.
;;;             : * Removed the learned-productions slot of the module and
;;;             :   instead made it a parameter on the productions themselves.
;;;             : * Updated update-params-for-compiled-production to not do
;;;             :   the utility computation, but instead to call the functions
;;;             :   in the utility-and-reward file.
;;; 2006.03.13 Dan
;;;             : * Removed all the utility parameters from the compilation
;;;             :   module because they're now part of the utility module.
;;; 2006.03.14 Dan
;;;             : * Fixed a bug that was introduced with the !safe-bind! fix
;;;             :   that caused RHS buffer references to be instantiated.
;;; 2006.03.14 Dan
;;;             : * Switched call to pp to (all-productions).
;;; 2006.07.12 Dan
;;;             : * Fixed the typo in the documentation of the :pct parameter.
;;; 2006.08.29 Dan
;;;             : * Fixed a bug in compose-productions where it was creating
;;;             :   the comment string for the new production.  It was iterating
;;;             :   over all buffers to determine if any were "removed" which
;;;             :   would throw a warning for a buffer that wasn't used now.
;;;             :   Instead, it only needs to check the buffers actually used
;;;             :   on the LHS of p2 which avoids the bug and is generally 
;;;             :   going to save a little time during compilation.
;;; 2006.09.07 Dan
;;;             : * Changed reset-production-compilation so that imaginal is
;;;             :   a goal type by default.
;;; 2006.11.10 Dan
;;;             : * Use the new dynamic slot of productions so that compilation
;;;             :   only creates p*s when a parent production is a p*.
;;; 2006.11.16 Dan
;;;             : * Changed update-params-for-compiled-production so that when
;;;             :   it deletes the new productions it also releases the name
;;;             :   symbol using release-name.
;;; 2006.11.17 Dan
;;;             : * Added a compilation-buffer-type macro and renamed the
;;;             :   function with -fct.
;;;             : * Added a call to values around the gethash in compilation-
;;;             :   buffer-type to suppress the second return value.
;;;             : * Changed specify-compilation-buffer-type to return t/nil only.
;;;             : * Fixed a bug in specify-compilation-buffer-type because it
;;;             :   was missing parameters in the calls to print-warning.
;;; 2007.01.15 Dan
;;;             : * Fixed a bug that was introduced with the change on 11/16
;;;             :   that would break when releasing the name.
;;; 2007.02.01 Dan
;;;             : * Fixed a bug in the instantiating necessary when a goal
;;;             :   style buffer in a p* modifies a chunk with a variablized
;;;             :   slot, or after any modification the p2 has a variablized
;;;             :   condition test.  Previously it only instantiated if both
;;;             :   cases where satisfied instead of either which could lead
;;;             :   to "incorrect" productions.  Probably a pretty rare situation,
;;;             :   since p*'s and production compilation are both sparsely 
;;;             :   used so I'm guessing that this hasn't been an issue for 
;;;             :   anyone else. (John didn't even encounter it!)
;;; 2007.04.10 Dan
;;;             : * Changed the comment string added to the new production so
;;;             :   that it only indicates the '- chunk' when the first production
;;;             :   actually made a request to the retrieval type buffer which
;;;             :   was matched in the second.  Previously, as long as the
;;;             :   second production tested such a buffer it would add that
;;;             :   to the comment.
;;;             : * Fixed a bad bug in compose-retrieval-buffer.  If p1 had
;;;             :   a retrieval request and p2 had a query of that buffer without
;;;             :   a harvest (thus it must be state busy or buffer empty) then
;;;             :   the composed production actually dropped the request from
;;;             :   the actions as if it was harvested!
;;;             : * Added a fix for an issue with retrieval drop-out when
;;;             :   the request had dynamic slot names.  There are still
;;;             :   a couple of issues to work out, but this should catch
;;;             :   many of the current problem cases.
;;; 2007.04.11 Dan
;;;             : * Added a better check for whether a compiled production is
;;;             :   dynamic and should be created with p* instead of just assuming
;;;             :   that it was based on the parents.
;;;             : * Added a new parameter to productions: compilation-instan.
;;;             :   It's used to hold the instantiation of p2 during compilation 
;;;             :   which is the bindings from the matching of p2 where some of the
;;;             :   variables may have been renamed to avoid conflicts with the 
;;;             :   variables from p1.
;;;             : * Using that new parameter, fixed a bug in the drop-out of
;;;             :   a retrieval which involved dynamic slots that had been renamed
;;;             :   in p2.
;;; 2007.05.21 Dan
;;;             : * Fix a bug that surprised me because nobody had found it yet -
;;;             :   when compiling out a retrieval if p2 used the "dropped" buffer
;;;             :   variable on the RHS it wasn't instantiated.  Not as easy a 
;;;             :   fix as first thought either because p1 could use that variable
;;;             :   name on it's LHS or RHS and those shouldn't be replaced...
;;;             : * Required adding the new production parameter retrieval-buffers-map
;;;             :   to keep things straight (sort of a hack, but I think it works
;;;             :   out ok).
;;; 2007.05.22 Dan
;;;             : * Similar to the bug listed above, compilation over goal style buffers
;;;             :   is allowed to progress (or fails with a warning in some cases)
;;;             :   when there is a use of the buffer variable in the actions of
;;;             :   p2 but a request in p1 invalidates that for the compiled production.
;;;             :   Updated the spreadsheet/data table to add a check for that.
;;; 2007.07.03 Dan
;;;             : * Fixed check-consistency because it was overly specific in
;;;             :   testing that things matched.  Replaced the eq test of the
;;;             :   slot contents with chunk-slot-equal.
;;; 2007.10.26 Dan [1.3]
;;;             : * Sorting the actions in the composed productions so that
;;;             :   the "same" production gets created in all systems.  Otherwise
;;;             :   they can vary in the action order which shouldn't matter, but
;;;             :   for some rare situations might.
;;; 2008.03.20 Dan
;;;             : * Putting in a test so that productions with multiple-value binds 
;;;             :   are always rejected from compilation.
;;; 2008.12.23 Dan
;;;             : * Put in code to make sure that new productions get added to
;;;             :   the procedural module the "right" way now.
;;; 2009.08.27 Dan
;;;             : * Added code to disable the consistency check between the
;;;             :   RHS modifications of p1 and the LHS tests of p2 for goal
;;;             :   style buffers when ppm is enabled.
;;; 2009.09.14 Dan
;;;             : * Fixed a bug in the consistency check added for the ppm change.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; General Docs:
;;; 
;;; The basic mechanism is that for any two productions that fire in sequence
;;; a new production may be created that is a composition of those two.
;;;
;;; To determine whether two productions can be composed and how they get 
;;; composed depends on what buffers are used and how they are used.
;;;
;;; Here's the high-level algorithm in a text-based state chart (best
;;; viewed in a fixed width font):
#|
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

                                                             start
                                                               |
                                                               V
                                                               |
                                                    -------------------------
        .--------------------.--------------------->| Wait for a production |
        |                    |                      -------------------------
        |                    |                                 |
        |                    |                                 V
        |                    |                                 |
        |                    |                      ------------------------- 
        |                    |                      | call it current       |
        |                    |                      -------------------------
        |                    |                                 |
        |                    |                                 V
        |                    ^                                 |
        |                    |                       /---------------------\
        |            ------------------             /  is current valid-p   \
        |            | clear previous | ------<--N- \                       / 
        |            ------------------              \---------------------/
        |                    |                                 | 
        |                    |                                 Y
        |                    |                                 |
        |                    ^                                 V
        |                    |                                 |
        ^                    N                                 |
        |                    |                       /---------------------\
 ----------------      /-----------\                /  is there a previous  \
 | set previous |     / is current  \---------<--N- \                       /
 | to current   |-<-Y-\ valid-1st-p /                \---------------------/
 ----------------      \-----------/                           |
                             |                                 | 
                             |                                 Y
                             |                                 |
                             |                                 |
                             ^                                 V
                             |                                 | 
                             |                       /---------------------\
                             |                      /   are previous and    \
                             +----------------<--N- \ current composable    /
                             |                       \---------------------/
                             |                                 | 
                             |                                 Y
                             |                                 |
                             ^                                 V
                             |                                 | 
                             |                      --------------------------
                             +----------------<---- | Compose new production |
                                                    --------------------------
|#

;;; The test for valid-p is that it have none of the following:
;;;    - LHS !eval!
;;;    - LHS !bind!
;;;    - LHS !safe-bind! (this is a precautionary stance for now)
;;;    - LHS !mv-bind!
;;;    - RHS !eval!
;;;    - RHS !bind!
;;;    - RHS !mv-bind!
;;;    - multiple LHS ='s for any one buffer.
;;;    - *NEW* No direct requests 
;;;    - *Temporary* No slot modifiers other than = in conditions
;;;      other than goal tests.
;;;
;;; The test for valid-1st-p is that it have none of the following:
;;;    - RHS !stop!
;;;    - multiple +<buffer> actions for a specific buffer of any style
;;;
;;;   Possible other conditions which may be added, but are not used now:
;;;   
;;;    - modifiers on a query
;;;    - queries other than state {busy, free, error} or buffer {full,empty,
;;;      requested or unrequested}
;;;
;;;
;;; The test of composable is a lot more complicated. 
;;; 
;;; First, the production must fire within the threshold time of each other.
;;; Then, for each buffer used in either production the composition charts
;;; are consulted to determine if its useage is composeable.  In addition,
;;; if the buffer tests are successful, there is an additional pass to
;;; check that the buffer actions in the first are compatible with the
;;; conditions in the second to avoid any problems with an "unusual" change
;;; in the buffers.
;;;
;;; The composition process considers buffers to fall into one of 4 general
;;; types (goal, retrieval, perceptual, and motor) and the mechanism differs
;;; based on the types of buffers used in the two productions.  The Microsoft 
;;; Excel file "compose.xls" in the docs directory lays out the rules that
;;; govern the composabilty of productions based on the types of buffers
;;; used and the conditions and actions they contain.
;;;
;;; That file is used to generate the composability tables used in this file.
;;; The idea is that if one wants to either modify or extend the compilation
;;; mechanism, then that can be done by changing or adding new spreadsheets
;;; and then rebuilding the corresponding tables in this file instead of
;;; having to recode the whole thing.  That may require also adding some new
;;; testing functions or composition functions, but it should not require
;;; changing the existing testing and composing functions.
;;;   
;;; The Microsoft Word document "compose.doc" in the docs directory describes
;;; the process used to compose the productions into a new one.
;;;
;;; The default assignment of buffers to types is as follows (assuming that
;;; a buffer by that name exists):
;;;
;;; Buffer name           Type
;;;  goal              goal
;;;  retrieval         retrieval
;;;  visual-location   perceptual
;;;  visual            perceptual
;;;  aural-location    perceptual
;;;  aural             perceptual
;;;  manual            motor
;;;  vocal             motor
;;; 
;;; Any other buffer will be assumed to be of type motor unless configured
;;; using the specify-compilation-buffer-type command (which can also be used
;;; to change the types for the default buffer assignments).
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; Public API:
;;; 
;;; defmacro specify-compilation-buffer-type (buffer-name buffer-type)
;;; defun   specify-compilation-buffer-type-fct (buffer-name buffer-type)
;;;
;;; buffer-name must be the name of a valid buffer in the model.
;;; buffer-type must be one of the symbols goal, retrieval, perceptual, motor.
;;;
;;; If the named buffer exists and the symbol for the buffer-type is valid this
;;; command will cause production compilation to treat the named buffer as a
;;; member of the specified type for composition purposes.
;;; 
;;; If the parameters are valid and there is a current production compilation
;;; module, then the command will return t otherwise it will print a warning 
;;; and return :error.
;;;
;;; If this command is to be used by a module to set its default type it
;;; should be done in the second module reset function.  If it is being set in
;;; the model, then it should occur within the body of the model.  Changing 
;;; the values at times other than reset or model creation are not advised and
;;; may lead to unpredictable behavior.
;;;
;;; defun show-compilation-buffer-types ()
;;;
;;; This command will print out a table showing the current compilation buffer
;;; type for all of the buffers in the system.  If there is no current module
;;; then it will print a warning.
;;; 
;;; It always returns nil.
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; Design Choices:
;;;
;;; For now, the plan is to keep this as a separate piece from the main 
;;; procedural system to avoid breaking anything that is working.
;;;  
;;; Eventually, once it's well tested it can be rolled into the main procedural,
;;; but until then keeping it separate seems to make the most sense.
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 
;;; The code
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#+:packaged-actr (in-package :act-r)
#+(and :clean-actr (not :packaged-actr) :ALLEGRO-IDE) (in-package :cg-user)
#-(or (not :clean-actr) :packaged-actr :ALLEGRO-IDE) (in-package :cl-user)


;;; Add a new parameter to productions to track who created it

(extend-productions user-created :default-value t)


;;; Add a new parameter to productions for holding the bindings
;;; needed during compilation which might have temporary variables
;;; replacing the actual production variables

(extend-productions compilation-instan :default-value nil)


;;; Add a new parameter to hold any remapping of duplicate
;;; retrieval-style buffer names from p1->p2 to handle the
;;; proper mapping for instantiation their use in the 
;;; compiled production.

(extend-productions retrieval-buffers-map :default-value nil)

;;; Globally define the possible composition types

(defconstant +valid-compilation-buffer-types+ 
    '(goal retrieval perceptual motor)
  "The default 4 classifications of buffers for production compilation")


;;; Globally define the composition tables - all modules use the same
;;; mechanisms but may define the buffers differently.

(defparameter *valid-compose-table* nil
  "Holds the lookup tables for determining composability")

(defparameter *buffer-mapping-table* nil
  "The lookup table of buffer-type to mapping function")

(defparameter *buffer-composers-table* nil
  "The lookup table of buffer-type to composing function")

(defvar *buffer-var-names* nil
  "The variable names of all current buffers")

(defstruct compilation-module
  trace
  epl
  previous
  previous-time
  (buffer-type-table (make-hash-table))
  ppm
  tt)


(defun create-composition-module (model-name)
  (declare (ignore model-name))
  
  ;; Create the tables once when the first module is instantiated
  
  (unless *valid-compose-table*
    (setf *valid-compose-table* (make-hash-table))
    
    (initialize-compose-table))
  
  (unless *buffer-composers-table*
    (setf *buffer-composers-table* (make-hash-table))
    
    (initialize-composers-table))
  
  
  (unless *buffer-mapping-table*
    (setf *buffer-mapping-table* (make-hash-table))
    
    (initialize-mappers-table))

  
  (make-compilation-module))

  
  

(defun reset-production-compilation (instance)
  (setf (compilation-module-previous instance) nil)
  (setf (compilation-module-previous-time instance) 0)
  
  (clrhash (compilation-module-buffer-type-table instance))
  
  (dolist (buffer (buffers))
    (case buffer
      (goal (setf (gethash buffer (compilation-module-buffer-type-table instance)) 'goal))
      (imaginal (setf (gethash buffer (compilation-module-buffer-type-table instance)) 'goal))
      (retrieval (setf (gethash buffer (compilation-module-buffer-type-table instance)) 'retrieval))
      (visual-location (setf (gethash buffer (compilation-module-buffer-type-table instance)) 'perceptual))
      (visual (setf (gethash buffer (compilation-module-buffer-type-table instance)) 'perceptual))
      (aural-location (setf (gethash buffer (compilation-module-buffer-type-table instance)) 'perceptual))
      (aural  (setf (gethash buffer (compilation-module-buffer-type-table instance)) 'perceptual))
      (manual (setf (gethash buffer (compilation-module-buffer-type-table instance)) 'motor))
      (vocal (setf (gethash buffer (compilation-module-buffer-type-table instance)) 'motor))
      (t (setf (gethash buffer (compilation-module-buffer-type-table instance)) 'motor))))
  
  
  (setf *buffer-var-names* (mapcar 
                               #'(lambda (x)
                                 (intern (concatenate 'string "=" (string x))))
                             (buffers)))
  )



(defun production-compilation-params (prod param)
  (cond ((consp param)
         (case (car param)
           
           (:pct (setf (compilation-module-trace prod) (cdr param)))
           (:tt (setf (compilation-module-tt prod) (cdr param)))
           (:epl (setf (compilation-module-epl prod) (cdr param)))
           (:ppm (setf (compilation-module-ppm prod) (cdr param)))))
        (t 
         (case param
           (:pct (compilation-module-trace prod))
           (:tt (compilation-module-tt prod))
           (:epl (compilation-module-epl prod))))))


(define-module-fct 'production-compilation
    nil
  (list (define-parameter :ppm :owner nil)
        (define-parameter :epl :default-value nil 
          :valid-test #'tornil :warning "T or nil"
          :documentation "Enable Production Learning")
        (define-parameter :pct :default-value nil 
          :valid-test #'tornil :warning "T or nil"
          :documentation "Production Compilation Trace")
        
        (define-parameter :tt :default-value 2.0
          :valid-test #'posnum :warning "a positive number"
          :documentation "Threshold time"))
  :version "1.3"
  :documentation "A module that assists the primary procedural module with compiling productions"
  :creation 'create-composition-module
  :reset 'reset-production-compilation
  :params 'production-compilation-params)




(defun compile-productions (production)
  (let ((module (get-module production-compilation))
        (p-name (production-name production)))
    
    (when (compilation-module-epl module)
      
      (when (compilation-module-trace module)
        (model-output "Production Compilation process started for ~s" p-name))
    
      (cond ((not (valid-compilation-production production))
             (when (compilation-module-trace module)
               (model-output "  Production ~s is not valid for compilation" p-name))
             (setf (compilation-module-previous module) nil))
            
            ((null (compilation-module-previous module))
             (when (compilation-module-trace module)
               (model-output "  No previous production to compose with."))
             (handle-check-valid-1st-p module production))
            ((> (- (mp-time) (compilation-module-previous-time module))
                (compilation-module-tt module))
             (when (compilation-module-trace module)
               (model-output "  Cannot compile ~s and ~s because the time between them exceeds the threshold time."
                             (car (compilation-module-previous module))
                             p-name))
             (handle-check-valid-1st-p module production))
            ((null (composeable-productions-p module (get-production (car (compilation-module-previous module))) production))
             (when (compilation-module-trace module)
               (model-output "  Production ~s and ~s cannot be composed." (car (compilation-module-previous module)) p-name))
             (handle-check-valid-1st-p module production))
            (t
             (when (compilation-module-trace module)
               (model-output "  Production ~s and ~s are being composed." (car (compilation-module-previous module)) p-name))
             (compose-productions module production)
             (handle-check-valid-1st-p module production))))))



(defun valid-compilation-production (prod)
  (not (or (find 'eval (production-lhs prod) :key #'cdar)
           (find 'eval (production-rhs prod) :key #'cdar)
           (find 'bind (production-lhs prod) :key #'cdar)
           (find 'bind (production-rhs prod) :key #'cdar)
           (find 'mv-bind (production-lhs prod) :key #'cdar)
           (find 'mv-bind (production-rhs prod) :key #'cdar)
           (find 'safe-bind (production-lhs prod) :key #'cdar)
           (check-for-duplicates #\= (production-lhs prod))
           (issues-direct-requests prod)
           (slot-modifers-other-than-= prod))))


(defun check-for-duplicates (char items)
  (let ((filtered (mapcar #'cdar 
                    (remove char items :key #'caar 
                            :test #'(lambda (x y)
                                      (not (eql x y)))))))
    (not (= (length filtered) 
            (length (remove-duplicates filtered))))))
           

(defun issues-direct-requests (prod)
  (let ((rep (produce-standard-representation prod)))
    (find-if #'(lambda (y) 
                 (unless (eq (first y) '!output!)
                   (let ((x (second y)))
                     (and (= (length x) 1)
                          (not (listp (first x)))))))
             (second rep))))


(defun slot-modifers-other-than-= (prod)
  (let ((rep (produce-standard-representation prod)))
    (dolist (condition (first rep))
      (unless (or (eq (car condition) '!safe-eval!)
                  (eq (car condition) '!safe-bind!))
                  
        (dolist (tests (second condition))
          (when (and (listp tests)
                     (= (length tests) 3)
                     (not (eql '= (car tests))))
            (return-from slot-modifers-other-than-= t)))))))


;;; The test for valid-1st-p is that it have none of the following:
;;;    - RHS !stop!
;;;    - multiple +<buffer> actions for a specific buffer of any style

(defun valid-1st-p (prod)
  (not (or (find 'stop (production-rhs prod) :key #'cdar)
           (check-for-duplicates #\+ (production-rhs prod)))))

(defun handle-check-valid-1st-p (module prod)
  (if (valid-1st-p prod)
      (progn
        (setf (compilation-module-previous module)
          (list (production-name prod)
                (copy-tree (production-bindings prod))))
        (setf (compilation-module-previous-time module) (mp-time))
        (when (compilation-module-trace module)
          (model-output "  Setting previous production to ~S."
                          (production-name prod))))
    (progn
      (when (compilation-module-trace module)
        (model-output "  Production ~s is not valid as a first production for compilation"
                        (production-name prod)))
      (setf (compilation-module-previous module) nil))))
    
    
    
(defun composeable-productions-p (module p1 p2)
  
  (dolist (buffer (remove-duplicates (append (production-lhs-buffers p1)
                                             (production-lhs-buffers p2)
                                             (production-rhs-buffers p1)
                                             (production-rhs-buffers p2))))
    
    (let* ((type (gethash buffer (compilation-module-buffer-type-table module)))
           (table (gethash type *valid-compose-table*))
           (p1-usage (get-buffer-index p1 buffer))
           (p2-usage (get-buffer-index p2 buffer))
           (index (vector p1-usage p2-usage))
           (value (gethash index table)))
      
      (unless (and value 
                   (or (eq value t) (funcall value buffer p1 p2)))
        
        (when (compilation-module-trace module)
          (model-output "  Buffer ~S prevents composition of these productions"
                          buffer))
        (return-from composeable-productions-p nil))))
  
  (dolist (buffer (intersection (production-rhs-buffers p1)
                                (production-lhs-buffers p2)) t)
    
    ;; Check for consistency...
    
    ;(pprint buffer)
    
    (case (gethash buffer 
                   (compilation-module-buffer-type-table module))
      (goal
       (case (get-buffer-index p1 buffer)
         ((4 12 13 20 28 29) ;; a RHS +
          (unless (check-consistency module (find (cons #\+ buffer) (production-rhs p1) :key #'car :test #'equal)
                                     (second (compilation-module-previous module))
                                     (find (cons #\= buffer) (production-lhs p2) :key #'car :test #'equal)
                                     (production-bindings p2))
            (return-from composeable-productions-p nil)))
         ((9 25) ;; a RHS =
          (unless (check-consistency module (cons (chunk-spec-chunk-type (third (find (cons #\= buffer) (production-lhs p1) :key #'car :test #'equal)))
                                           (find (cons #\= buffer) (production-rhs p1) :key #'car :test #'equal))
                                     (second (compilation-module-previous module))
                                     (find (cons #\= buffer) (production-lhs p2) :key #'car :test #'equal)
                                     (production-bindings p2))
            (return-from composeable-productions-p nil)))
         (t
          ;; don't care about other cases right now.
          ))
       )
      (retrieval
       ;; no check necessary
       ;; modifications not allowed
       ;; may want inconsistencies with partial matching
       )
      (perceptual
       ;; no check necessary
       ;; modifications not allowed
       ;; can't compile across a request
       )
      (motor
       ;; no check necessary
       ;; modifications not allowed
       ;; can't compile across a request
       )
      (t
       ;; no other styles by default - need to generalize this at some point
       ))))
                                      
(defun check-consistency (module action action-bindings condition cond-bindings)
  (cond ((consp (car action)) ;; it's a +
         
         (let* ((action-spec (define-chunk-spec-fct (replace-variables (second action) action-bindings)))
                (action-map (chunk-spec-slot-spec action-spec))
                (cond-spec (third condition))
                (cond-map (replace-variables (fifth condition) cond-bindings))
                (action-type (chunk-spec-chunk-type action-spec))
                (cond-type (chunk-spec-chunk-type cond-spec)))
           
           (unless (eq action-type cond-type)
             (return-from check-consistency nil))
           
           (unless (compilation-module-ppm module)
             (dolist (cond cond-map)
               (let ((action (find (second cond) action-map :test #'(lambda (x y)
                                                                    (and (eq (first y) '=)
                                                                         (eq (second y) x))))))
               (when action
                 (unless (chunk-slot-equal (third cond) (third action))
                   (return-from check-consistency nil))))))))
        (t ; this is the  = case
         
         (let* ((action-spec (define-chunk-spec-fct (replace-variables (append (list 'isa (car action)) (third action)) action-bindings)))
                (action-map (chunk-spec-slot-spec action-spec))
                (cond-spec (third condition))
                (cond-map (replace-variables (fifth condition) cond-bindings))
                (action-type (car action))
                (cond-type (chunk-spec-chunk-type cond-spec)))
           
           (unless (eq action-type cond-type)
             (return-from check-consistency nil))
           
           (unless (compilation-module-ppm module)
             (dolist (cond cond-map)
               (let ((action (find (second cond) action-map :test #'(lambda (x y)
                                                                      (and (eq (first y) '=)
                                                                           (eq (second y) x))))))
                 (when action
                   (unless (chunk-slot-equal (third cond) (third action))
                     (return-from check-consistency nil)))))))))
  t)
          


(defun get-buffer-index (production buffer)
  (unless (production-buffer-indices production)
    (setf (production-buffer-indices production)
      (mapcar #'(lambda (buffer) (cons buffer 0))
        (remove-duplicates (append (get-buffers (production-lhs production))
                                   (get-buffers (production-rhs production))))))
    (dolist (x (production-buffer-indices production))
      (when (find (cons #\= (car x)) (production-lhs production) :key #'car :test #'equal)
        (incf (cdr x) 8))
      (when (find (cons #\? (car x)) (production-lhs production) :key #'car :test #'equal)
        (incf (cdr x) 16))
      (when (find (cons #\= (car x)) (production-rhs production) :key #'car :test #'equal)
        (incf (cdr x) 1))
      (when (find (cons #\- (car x)) (production-rhs production) :key #'car :test #'equal)
        (incf (cdr x) 2))
      (when (find (cons #\+ (car x)) (production-rhs production) :key #'car :test #'equal)
        (incf (cdr x) 4))))
  
  (aif (cdr (assoc buffer (production-buffer-indices production)))
       it
       0))

(defun get-buffers (items)
  (let ((res nil))
    (dolist (x items res)
      (unless (eq #\! (caar x))
        (push (cdar x) res)))))
      
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; These next two functions were generated with this call:
;;
;; CG-USER(112): (build-initializers (list "ACT-R6:docs;goal-compilation.txt" 
;;                                        "ACT-R6:docs;retrieval-compilation.txt"
;;                                        "ACT-R6:docs;perceptual-compilation.txt"
;;                                        "ACT-R6:docs;motor-compilation.txt"))
;;
;; and the text files came from the sheets of the compilation.xls spreadsheet.

(defun initialize-compose-table ()
   "Function that initializes the table of legal buffer compositions.
    DO NOT MODIFY THIS FUNCTON DIRECTLY - BUILD IT USING
    THE build-initializers FUNCTION AND THE SPREADSHEETS."
  ;; style: GOAL
  (unless (find 'GOAL +valid-compilation-buffer-types+)
      (print-warning "Invalid buffer style GOAL"))
  (setf (gethash 'GOAL *valid-compose-table*) (make-hash-table :test #'equalp))
  (setf (gethash (vector  0  4) (gethash 'GOAL *valid-compose-table*)) 'T)
  (setf (gethash (vector  0  8) (gethash 'GOAL *valid-compose-table*)) 'T)
  (setf (gethash (vector  0  9) (gethash 'GOAL *valid-compose-table*)) 'T)
  (setf (gethash (vector  0 12) (gethash 'GOAL *valid-compose-table*)) 'T)
  (setf (gethash (vector  0 13) (gethash 'GOAL *valid-compose-table*)) 'T)
  (setf (gethash (vector  4  0) (gethash 'GOAL *valid-compose-table*)) 'T)
  (setf (gethash (vector  4  8) (gethash 'GOAL *valid-compose-table*)) 'NO-RHS-REFERENCE)
  (setf (gethash (vector  4  9) (gethash 'GOAL *valid-compose-table*)) 'NO-RHS-REFERENCE)
  (setf (gethash (vector  8  0) (gethash 'GOAL *valid-compose-table*)) 'T)
  (setf (gethash (vector  8  4) (gethash 'GOAL *valid-compose-table*)) 'T)
  (setf (gethash (vector  8  8) (gethash 'GOAL *valid-compose-table*)) 'T)
  (setf (gethash (vector  8  9) (gethash 'GOAL *valid-compose-table*)) 'T)
  (setf (gethash (vector  8 12) (gethash 'GOAL *valid-compose-table*)) 'T)
  (setf (gethash (vector  8 13) (gethash 'GOAL *valid-compose-table*)) 'T)
  (setf (gethash (vector  9  0) (gethash 'GOAL *valid-compose-table*)) 'T)
  (setf (gethash (vector  9  4) (gethash 'GOAL *valid-compose-table*)) 'T)
  (setf (gethash (vector  9  8) (gethash 'GOAL *valid-compose-table*)) 'T)
  (setf (gethash (vector  9  9) (gethash 'GOAL *valid-compose-table*)) 'T)
  (setf (gethash (vector  9 12) (gethash 'GOAL *valid-compose-table*)) 'T)
  (setf (gethash (vector  9 13) (gethash 'GOAL *valid-compose-table*)) 'T)
  (setf (gethash (vector 12  0) (gethash 'GOAL *valid-compose-table*)) 'T)
  (setf (gethash (vector 12  8) (gethash 'GOAL *valid-compose-table*)) 'NO-RHS-REFERENCE)
  (setf (gethash (vector 12  9) (gethash 'GOAL *valid-compose-table*)) 'NO-RHS-REFERENCE)
  (setf (gethash (vector 13  0) (gethash 'GOAL *valid-compose-table*)) 'T)
  (setf (gethash (vector 13  8) (gethash 'GOAL *valid-compose-table*)) 'NO-RHS-REFERENCE)
  (setf (gethash (vector 13  9) (gethash 'GOAL *valid-compose-table*)) 'NO-RHS-REFERENCE)
  ;; style: RETRIEVAL
  (unless (find 'RETRIEVAL +valid-compilation-buffer-types+)
      (print-warning "Invalid buffer style RETRIEVAL"))
  (setf (gethash 'RETRIEVAL *valid-compose-table*) (make-hash-table :test #'equalp))
  (setf (gethash (vector  0  4) (gethash 'RETRIEVAL *valid-compose-table*)) 'T)
  (setf (gethash (vector  0  8) (gethash 'RETRIEVAL *valid-compose-table*)) 'T)
  (setf (gethash (vector  0 12) (gethash 'RETRIEVAL *valid-compose-table*)) 'T)
  (setf (gethash (vector  0 16) (gethash 'RETRIEVAL *valid-compose-table*)) 'T)
  (setf (gethash (vector  0 20) (gethash 'RETRIEVAL *valid-compose-table*)) 'T)
  (setf (gethash (vector  0 24) (gethash 'RETRIEVAL *valid-compose-table*)) 'T)
  (setf (gethash (vector  0 28) (gethash 'RETRIEVAL *valid-compose-table*)) 'T)
  (setf (gethash (vector  4  0) (gethash 'RETRIEVAL *valid-compose-table*)) 'T)
  (setf (gethash (vector  4  4) (gethash 'RETRIEVAL *valid-compose-table*)) 'T)
  (setf (gethash (vector  4  8) (gethash 'RETRIEVAL *valid-compose-table*)) 'T)
  (setf (gethash (vector  4 12) (gethash 'RETRIEVAL *valid-compose-table*)) 'T)
  (setf (gethash (vector  4 16) (gethash 'RETRIEVAL *valid-compose-table*)) 'R-B-C1)
  (setf (gethash (vector  4 20) (gethash 'RETRIEVAL *valid-compose-table*)) 'R-B-C1)
  (setf (gethash (vector  4 24) (gethash 'RETRIEVAL *valid-compose-table*)) 'T)
  (setf (gethash (vector  4 28) (gethash 'RETRIEVAL *valid-compose-table*)) 'T)
  (setf (gethash (vector  8  0) (gethash 'RETRIEVAL *valid-compose-table*)) 'T)
  (setf (gethash (vector  8  4) (gethash 'RETRIEVAL *valid-compose-table*)) 'T)
  (setf (gethash (vector  8 16) (gethash 'RETRIEVAL *valid-compose-table*)) 'T)
  (setf (gethash (vector  8 20) (gethash 'RETRIEVAL *valid-compose-table*)) 'T)
  (setf (gethash (vector 12  0) (gethash 'RETRIEVAL *valid-compose-table*)) 'T)
  (setf (gethash (vector 12  4) (gethash 'RETRIEVAL *valid-compose-table*)) 'T)
  (setf (gethash (vector 12  8) (gethash 'RETRIEVAL *valid-compose-table*)) 'T)
  (setf (gethash (vector 12 12) (gethash 'RETRIEVAL *valid-compose-table*)) 'T)
  (setf (gethash (vector 12 16) (gethash 'RETRIEVAL *valid-compose-table*)) 'R-B-C1)
  (setf (gethash (vector 12 20) (gethash 'RETRIEVAL *valid-compose-table*)) 'R-B-C1)
  (setf (gethash (vector 12 24) (gethash 'RETRIEVAL *valid-compose-table*)) 'T)
  (setf (gethash (vector 12 28) (gethash 'RETRIEVAL *valid-compose-table*)) 'T)
  (setf (gethash (vector 16  0) (gethash 'RETRIEVAL *valid-compose-table*)) 'T)
  (setf (gethash (vector 16  4) (gethash 'RETRIEVAL *valid-compose-table*)) 'T)
  (setf (gethash (vector 16  8) (gethash 'RETRIEVAL *valid-compose-table*)) 'T)
  (setf (gethash (vector 16 12) (gethash 'RETRIEVAL *valid-compose-table*)) 'T)
  (setf (gethash (vector 16 16) (gethash 'RETRIEVAL *valid-compose-table*)) 'R-B-C2)
  (setf (gethash (vector 16 20) (gethash 'RETRIEVAL *valid-compose-table*)) 'R-B-C2)
  (setf (gethash (vector 16 24) (gethash 'RETRIEVAL *valid-compose-table*)) 'R-B-C2)
  (setf (gethash (vector 16 28) (gethash 'RETRIEVAL *valid-compose-table*)) 'R-B-C2)
  (setf (gethash (vector 20  0) (gethash 'RETRIEVAL *valid-compose-table*)) 'T)
  (setf (gethash (vector 20  4) (gethash 'RETRIEVAL *valid-compose-table*)) 'T)
  (setf (gethash (vector 20  8) (gethash 'RETRIEVAL *valid-compose-table*)) 'T)
  (setf (gethash (vector 20 12) (gethash 'RETRIEVAL *valid-compose-table*)) 'T)
  (setf (gethash (vector 20 16) (gethash 'RETRIEVAL *valid-compose-table*)) 'R-B-C1)
  (setf (gethash (vector 20 20) (gethash 'RETRIEVAL *valid-compose-table*)) 'R-B-C1)
  (setf (gethash (vector 20 24) (gethash 'RETRIEVAL *valid-compose-table*)) 'T)
  (setf (gethash (vector 20 28) (gethash 'RETRIEVAL *valid-compose-table*)) 'T)
  (setf (gethash (vector 24  0) (gethash 'RETRIEVAL *valid-compose-table*)) 'T)
  (setf (gethash (vector 24  4) (gethash 'RETRIEVAL *valid-compose-table*)) 'T)
  (setf (gethash (vector 24 16) (gethash 'RETRIEVAL *valid-compose-table*)) 'R-B-C2)
  (setf (gethash (vector 24 20) (gethash 'RETRIEVAL *valid-compose-table*)) 'R-B-C2)
  (setf (gethash (vector 28  0) (gethash 'RETRIEVAL *valid-compose-table*)) 'T)
  (setf (gethash (vector 28  4) (gethash 'RETRIEVAL *valid-compose-table*)) 'T)
  (setf (gethash (vector 28  8) (gethash 'RETRIEVAL *valid-compose-table*)) 'T)
  (setf (gethash (vector 28 12) (gethash 'RETRIEVAL *valid-compose-table*)) 'T)
  (setf (gethash (vector 28 16) (gethash 'RETRIEVAL *valid-compose-table*)) 'R-B-C1)
  (setf (gethash (vector 28 20) (gethash 'RETRIEVAL *valid-compose-table*)) 'R-B-C1)
  (setf (gethash (vector 28 24) (gethash 'RETRIEVAL *valid-compose-table*)) 'T)
  (setf (gethash (vector 28 28) (gethash 'RETRIEVAL *valid-compose-table*)) 'T)
  ;; style: PERCEPTUAL
  (unless (find 'PERCEPTUAL +valid-compilation-buffer-types+)
      (print-warning "Invalid buffer style PERCEPTUAL"))
  (setf (gethash 'PERCEPTUAL *valid-compose-table*) (make-hash-table :test #'equalp))
  (setf (gethash (vector  0  4) (gethash 'PERCEPTUAL *valid-compose-table*)) 'T)
  (setf (gethash (vector  0  8) (gethash 'PERCEPTUAL *valid-compose-table*)) 'T)
  (setf (gethash (vector  0 12) (gethash 'PERCEPTUAL *valid-compose-table*)) 'T)
  (setf (gethash (vector  0 16) (gethash 'PERCEPTUAL *valid-compose-table*)) 'T)
  (setf (gethash (vector  0 20) (gethash 'PERCEPTUAL *valid-compose-table*)) 'T)
  (setf (gethash (vector  0 24) (gethash 'PERCEPTUAL *valid-compose-table*)) 'T)
  (setf (gethash (vector  0 28) (gethash 'PERCEPTUAL *valid-compose-table*)) 'T)
  (setf (gethash (vector  4  0) (gethash 'PERCEPTUAL *valid-compose-table*)) 'T)
  (setf (gethash (vector  4 16) (gethash 'PERCEPTUAL *valid-compose-table*)) 'R-B-C1)
  (setf (gethash (vector  8  0) (gethash 'PERCEPTUAL *valid-compose-table*)) 'T)
  (setf (gethash (vector  8  4) (gethash 'PERCEPTUAL *valid-compose-table*)) 'T)
  (setf (gethash (vector  8 16) (gethash 'PERCEPTUAL *valid-compose-table*)) 'T)
  (setf (gethash (vector  8 20) (gethash 'PERCEPTUAL *valid-compose-table*)) 'T)
  (setf (gethash (vector 12  0) (gethash 'PERCEPTUAL *valid-compose-table*)) 'T)
  (setf (gethash (vector 12 16) (gethash 'PERCEPTUAL *valid-compose-table*)) 'R-B-C1)
  (setf (gethash (vector 16  0) (gethash 'PERCEPTUAL *valid-compose-table*)) 'T)
  (setf (gethash (vector 16  4) (gethash 'PERCEPTUAL *valid-compose-table*)) 'T)
  (setf (gethash (vector 16  8) (gethash 'PERCEPTUAL *valid-compose-table*)) 'T)
  (setf (gethash (vector 16 12) (gethash 'PERCEPTUAL *valid-compose-table*)) 'T)
  (setf (gethash (vector 16 16) (gethash 'PERCEPTUAL *valid-compose-table*)) 'R-B-C2)
  (setf (gethash (vector 16 20) (gethash 'PERCEPTUAL *valid-compose-table*)) 'R-B-C2)
  (setf (gethash (vector 16 24) (gethash 'PERCEPTUAL *valid-compose-table*)) 'R-B-C2)
  (setf (gethash (vector 16 28) (gethash 'PERCEPTUAL *valid-compose-table*)) 'R-B-C2)
  (setf (gethash (vector 20  0) (gethash 'PERCEPTUAL *valid-compose-table*)) 'T)
  (setf (gethash (vector 20 16) (gethash 'PERCEPTUAL *valid-compose-table*)) 'R-B-C1)
  (setf (gethash (vector 24  0) (gethash 'PERCEPTUAL *valid-compose-table*)) 'T)
  (setf (gethash (vector 24  4) (gethash 'PERCEPTUAL *valid-compose-table*)) 'T)
  (setf (gethash (vector 24 16) (gethash 'PERCEPTUAL *valid-compose-table*)) 'R-B-C2)
  (setf (gethash (vector 24 20) (gethash 'PERCEPTUAL *valid-compose-table*)) 'R-B-C2)
  (setf (gethash (vector 28  0) (gethash 'PERCEPTUAL *valid-compose-table*)) 'T)
  (setf (gethash (vector 28 16) (gethash 'PERCEPTUAL *valid-compose-table*)) 'R-B-C1)
  ;; style: MOTOR
  (unless (find 'MOTOR +valid-compilation-buffer-types+)
      (print-warning "Invalid buffer style MOTOR"))
  (setf (gethash 'MOTOR *valid-compose-table*) (make-hash-table :test #'equalp))
  (setf (gethash (vector  0  4) (gethash 'MOTOR *valid-compose-table*)) 'T)
  (setf (gethash (vector  0 16) (gethash 'MOTOR *valid-compose-table*)) 'T)
  (setf (gethash (vector  0 20) (gethash 'MOTOR *valid-compose-table*)) 'T)
  (setf (gethash (vector  4  0) (gethash 'MOTOR *valid-compose-table*)) 'T)
  (setf (gethash (vector  4 16) (gethash 'MOTOR *valid-compose-table*)) 'R-B-C1)
  (setf (gethash (vector 16  0) (gethash 'MOTOR *valid-compose-table*)) 'T)
  (setf (gethash (vector 16  4) (gethash 'MOTOR *valid-compose-table*)) 'T)
  (setf (gethash (vector 16 16) (gethash 'MOTOR *valid-compose-table*)) 'R-B-C2)
  (setf (gethash (vector 16 20) (gethash 'MOTOR *valid-compose-table*)) 'R-B-C2)
  (setf (gethash (vector 20  0) (gethash 'MOTOR *valid-compose-table*)) 'T)
  (setf (gethash (vector 20 16) (gethash 'MOTOR *valid-compose-table*)) 'R-B-C1)
)
(defun initialize-mappers-table ()
   "Function that initializes the table of buffer composition mapping functions.
    DO NOT MODIFY THIS FUNCTON DIRECTLY - BUILD IT USING
    THE build-initializers FUNCTION AND THE SPREADSHEETS."
  (setf (gethash 'MOTOR *buffer-mapping-table*) 'MAP-MOTOR-BUFFER)
  (setf (gethash 'PERCEPTUAL *buffer-mapping-table*) 'MAP-PERCEPTUAL-BUFFER)
  (setf (gethash 'RETRIEVAL *buffer-mapping-table*) 'MAP-RETRIEVAL-BUFFER)
  (setf (gethash 'GOAL *buffer-mapping-table*) 'MAP-GOAL-BUFFER)
)
(defun initialize-composers-table ()
   "Function that initializes the table of buffer composition functions.
    DO NOT MODIFY THIS FUNCTON DIRECTLY - BUILD IT USING
    THE build-initializers FUNCTION AND THE SPREADSHEETS."
  (setf (gethash 'MOTOR *buffer-composers-table*) 'COMPOSE-MOTOR-BUFFER)
  (setf (gethash 'PERCEPTUAL *buffer-composers-table*) 'COMPOSE-PERCEPTUAL-BUFFER)
  (setf (gethash 'RETRIEVAL *buffer-composers-table*) 'COMPOSE-RETRIEVAL-BUFFER)
  (setf (gethash 'GOAL *buffer-composers-table*) 'COMPOSE-GOAL-BUFFER)
)
(defun r-b-c1 (buffer p1 p2)
  "Compilation check for queries such that p2 only uses 'buffer empty' or
   'state busy'"
  (declare (ignore p1))
  (let ((queries (mapcan #'third  (copy-tree (remove-if-not 
                                             #'(lambda (x)
                                                 (equal (car x) (cons #\? buffer)))
                                             (production-lhs p2))))))
    (every #'(lambda (x)      
               (eq (first x) '=)
               (or (and (eq (second x) 'state)
                        (eq (third x) 'busy))
                   (and (eq (second x) 'buffer)
                        (eq (third x) 'empty))))
           
           queries)))

(defun r-b-c2 (buffer p1 p2)
  "queries in p1 and p2 must be the same
   NOTE: this doesn't take into account any variables at this time"
  (let ((queries-1 (remove-duplicates
                    (mapcan #'third  (copy-tree (remove-if-not 
                                                 #'(lambda (x)
                                                     (equal (car x) (cons #\? buffer)))
                                                 (production-lhs p1))))
                    :test #'equal))
        (queries-2 (remove-duplicates 
                    (mapcan #'third  (copy-tree (remove-if-not 
                                                 #'(lambda (x)
                                                     (equal (car x) (cons #\? buffer)))
                                                 (production-lhs p2))))
                    :test #'equal)))
    
    (= (length queries-1) (length queries-2) 
       (length (remove-duplicates (append queries-1 queries-2) :test #'equal)))))


(defun no-rhs-reference (buffer p1 p2)
  "Can't compile if the variable naming the buffer is used in the actions of p2"
  (not (recursive-find (intern (concatenate 'string "=" (symbol-name buffer)))
                       (second (production-standard-rep p2))))) 

(defun compose-productions (module p2)
  ;(print-warning "Composition process not yet operational")
  
  (let* ((p1 (get-production (first (compilation-module-previous module))))
         (p1-s (produce-standard-representation p1))
         (p2-s (produce-standard-representation p2))
         (p1-variables (production-variables p1))
         (p2-variables (production-variables p2))
         (p1-basic-vars (remove-buffers p1-variables))
         (p2-basic-vars (remove-buffers p2-variables))
         (p2-name (production-name p2))
         (new-bindings nil))
    
    (setf (production-compilation-instan p2-name) (production-bindings p2))
    
    (awhen (intersection p1-basic-vars p2-basic-vars)
           (multiple-value-setq (p2-s new-bindings) 
             (rename-variables p2-s it (union p1-basic-vars p2-basic-vars)))
    
           (setf (production-compilation-instan p2-name) 
             (replace-variables (production-compilation-instan p2-name) new-bindings))
           
           (setf (production-retrieval-buffers-map p2-name)
             (remove-if-not (lambda (x) (find x *buffer-var-names*))
                            new-bindings  :key #'car))
           )
    
    
    ;; Even though the instantiation of variablized slots only pertains
    ;; to goal style buffers it has to take place prior to the other
    ;; mappings so can't be put into the specific goal composition function.
    
    ;; The only case where this needs to happen is when it's a goal
    ;; style buffer and p1 is of index 9 - that's the only time there's
    ;; a RHS = action that could require instantiating.
    
    ;; AND it must happen if there's a variablized slot in either the
    ;; action of p1 or the condition of p2 because otherwise a bad
    ;; mapping could result!
    
    ;(pprint p1-s)
    ;(pprint p2-s)
    
    (dolist (b (production-buffer-indices p1))
      (when (and (eq (compilation-buffer-type-fct (car b)) 'goal)
                 (= (cdr b) 9))
        
        (let* ((b= (intern (concatenate 'string "=" (string (car b)) ">")))
               (c2 (copy-tree (find b= (first p2-s) :key #'car)))
               (a1= (copy-tree (find b= (second p1-s) :key #'car)))
               (mod-vars (mapcan (lambda (x)
                                   (when (chunk-spec-variable-p (car x))
                                     (list (car x))))
                           (cadr a1=)))
               (cond-vars (mapcan (lambda (x)
                                    (when (chunk-spec-variable-p (second x))
                                      (list (second x))))
                            (cdadr c2))))
          
          ;
          ;(pprint b=)
          ;(pprint c2)
          ;(pprint (cdadr c2))
          ;(pprint a1=)
          
          ;(pprint mod-vars)
          ;(pprint cond-vars)
          
          ;(pprint (second (compilation-module-previous 
          ;                 (get-module production-compilation))))
          ;(pprint p2-instans)
          
          
          (cond ((and mod-vars cond-vars)
                 (let* ((p1-instantiations (second (compilation-module-previous 
                                                    (get-module production-compilation))))
                        
                        
                        (s1 (remove-if-not (lambda (x) (find x mod-vars)) p1-instantiations :key #'car))
                        (s2 (remove-if-not (lambda (x) (find x cond-vars)) (production-compilation-instan p2-name) :key #'car)))
                   
                   (dolist (mv s1)
                     (dolist (cv (remove-if-not (lambda (x) (eq (cdr mv) x)) s2 :key #'cdr))
                       
                       (setf p1-s (replace-variables-special p1-s (list mv)))
                       (setf p2-s (replace-variables-special p2-s (list cv)))))))
                ((and mod-vars (cdadr c2))  ;; variables in the modification and any slots tested in c2
                 (let* ((p1-instantiations (second (compilation-module-previous 
                                                    (get-module production-compilation))))
                        
                        
                        (s1 (remove-if-not (lambda (x) (find x mod-vars)) p1-instantiations :key #'car)))
                   
                   (dolist (mv s1)
                       (setf p1-s (replace-variables-special p1-s (list mv))))))
                (cond-vars
                 (let ((s2 (remove-if-not (lambda (x) (find x cond-vars)) (production-compilation-instan p2-name) :key #'car)))
                     (dolist (cv s2)
                       (setf p2-s (replace-variables-special p2-s (list cv))))))))))
    
    ;(pprint p1-s)
    ;(pprint p2-s)
        
    (let ((mappings nil))
      (dolist (buffer (union (mapcar #'car (production-buffer-indices p1))
                             (mapcar #'car (production-buffer-indices p2))))
        ;(pprint buffer)
        (aif (get-mapping-function buffer)
             (setf mappings (append (funcall it p1 p1-s p2 p2-s buffer) mappings))
             (return-from compose-productions nil))
        ;(pprint mappings)
        )
      
      ;(pprint mappings)
      
      ;;; Current mechanism for !safe-bind! on the RHS of P1 is to
      ;;; add its binding as a constant value and drop the bind.
      
      
      ;;; Here we add the binding to the mappings
      
      (dolist (x (second p1-s))
        (when (eq (car x) '!safe-bind!)
          ;(pprint x)
          (push-last (assoc (car (second x)) 
                            (second (compilation-module-previous module)))
                     mappings)
          ;(pprint 'variables)
          (dolist (y (find-variables (cdr (second x))))
            (push-last (assoc y (second (compilation-module-previous module)))
                       mappings))
          ;(pprint 'not-variables)
          ))

      
      (setf mappings (remove-duplicates mappings))
      (setf mappings (sort mappings #'< :key #'(lambda (x)
                                                 (if (constant-value-p (cdr x))
                                                     1 0))))
      
      
      ;(pprint mappings)
      
      (loop
        (let ((mapping (pop mappings)))
          (when (null mapping) (return))
          (setf p1-s (replace-variables-special p1-s (list mapping)))
          (setf p2-s (replace-variables-special p2-s (list mapping)))
          (when (find (car mapping) mappings :key #'car)
            (dolist (x mappings)
              (when (eq (car x) (car mapping))
                (replace mappings (list (cons (cdr mapping) (cdr x))) :start1 (position x mappings :test #'equal)))))))
      
      ;(pprint p1-s)
      ;(pprint p2-s)
      
      (let ((p3-s (list nil nil)))
        (dolist (buffer (union (mapcar #'car (production-buffer-indices p1))
                               (mapcar #'car (production-buffer-indices p2))))
          
          ;(pprint buffer)
          
          (aif (get-composing-function buffer)
               (let ((vals (funcall it p1 p1-s p2 p2-s buffer)))
                 ;(pprint it)
                 ;(pprint vals)
                 (setf (first p3-s) (append (first p3-s) (first vals)))
                 (setf (second p3-s) (append (second p3-s) (second vals))))
               (return-from compose-productions nil)))
        
        
        ;; Copy over anything that isn't a buffer reference
        
        ;; Making sure that the p1 stuff comes before the
        ;; p2 stuff in the new production (since it's being
        ;; pushed it must go backwards)

        
        
        
        (dolist (x (first p2-s))
          (when (find (car x) '(!safe-eval!))
            (push x (first p3-s))))
        
        ;;; need to make sure binds come before evals from the p2 stuff
        ;;; so just do it as a quick and dirty two pass now
        ;;; original order might be nice, but this should handle things
        ;;; for now since that gets munged in the standard rep...
        
        (dolist (x (second p2-s))
          (when (find (car x) '(!safe-bind!))
            (push x (second p3-s))))
        
        (dolist (x (second p2-s))
          (when (find (car x) '(!safe-eval! !output!))
            (push x (second p3-s))))
        
        
        (dolist (x (first p1-s))
          (when (find (car x) '(!safe-eval!))
            (unless (find x (first p3-s) :test #'equal)
              (push x (first p3-s)))))
        
        ;;; Here's where we remove the bind.
        
        (dolist (x (second p1-s))
          (when (find (car x) '(#|!safe-bind!|# !safe-eval! !output! !stop!))
            (unless (find x (second p3-s) :test #'equal)
              (push x (second p3-s)))))
        
                      
        ;(pprint p3-s)
        
        ;; Double check that everything gets bound 
        ;; The assumption being that it had to come from the second
        ;; production to get lost (through a retrieval removal or 
        ;; colapsing of conditions)
        
        (let ((lhs-vars (find-variables (mapcar #'cdr (first p3-s))))
              (rhs-vars (find-variables (mapcar #'cdr (second p3-s))))
              (rhs-bindings (mapcar #'caadr (remove '!safe-bind! (second p3-s) :test-not #'eql :key #'car))))
          
         ; (pprint lhs-vars)
         ; (pprint rhs-vars)
         ; (pprint rhs-bindings)
          
          (dolist (v rhs-vars)
            (unless (or (find v *buffer-var-names*) ;; don't want to bind the buffer refs...
                        (find v lhs-vars)
                        (find v rhs-bindings)
                        )
              
              ;(pprint v)
              (setf (second p3-s) (replace-variables (second p3-s) (list (assoc v (production-compilation-instan p2-name))))))))

        
        ;(pprint p3-s)
        
        (let ((post-conditions nil)
              (new-p nil)
              (dynamic nil))
          
          
          (push (new-production-name) new-p)
          
          (push (format nil "~A & ~A~{~@[ - ~a~]~}"
                  (production-name p1) (production-name p2)
                  (mapcan #'(lambda (x)
                              (when (and (eq 'retrieval (get-buffer-composition-type x))
                                         (find (cdr (assoc x (production-buffer-indices p1))) 
                                               '(4 6 12 13 14 15 20 22 28 29 30 31)))  ;; require the request in the first
                                (list (aif (chunk-copied-from-fct (cdr (assoc (read-from-string (format nil "=~a" x)) (production-bindings p2))))
                                           it
                                           (cdr (assoc (read-from-string (format nil "=~a" x)) (production-bindings p2)))))))
                    (production-lhs-buffers p2)))
                new-p)
                    
          (dolist (condition (sort-conditions (first p3-s)))
            
            ;(pprint condition)
            
            (if (find (car condition) '(!safe-bind! !safe-eval! !output! !stop!))
                (progn
                  (push (car condition) post-conditions)
                  (push (first (second condition)) post-conditions))
              
              (progn
                (push (car condition) new-p)
                (dolist (test (second condition))
                  (when (and (= (length test) 3)
                             (chunk-spec-variable-p (second test)))
                    (setf dynamic t))

                  (dolist (x (if (and (= (length test) 3)
                                      (eq (car test) '=))
                                 (cdr test)
                               test))
                    (push x new-p)))))
            )
          
          
          (when post-conditions
            (setf new-p (append post-conditions new-p)))
          
        
          (push '==> new-p)
          
          
          (dolist (action (sort-actions (second p3-s)))
            
            ;(pprint action)
            
            (push (car action) new-p)
            
            
            
            (cond ((find (car action) '(!safe-eval! !output!))
                   (push (first (second action)) new-p))
                  ((eq (car action) '!safe-bind!)
                   (push (first (second action)) new-p)
                   (push (second (second action)) new-p))
                  ((null (second action))
                   )
                  ((and (= (length (second action)) 1)
                        (not (listp (first (second action)))))
                   (push (first (second action)) new-p))
                  (t
                   (dolist (test (second action))
                     
                     (when (or (and (= (length test) 3)
                                    (chunk-spec-variable-p (second test)))
                               (and (= (length test) 2)
                                    (chunk-spec-variable-p (first test))))
                       (setf dynamic t))

                     (dolist (x (if (and (= (length test) 3)
                                      (eq (car test) '=))
                                 (cdr test)
                               test))
                    (push x new-p))))))
          
          ;(pprint (reverse new-p))
          
          (let ((procedural (get-module procedural)))
            (setf (procedural-delay-tree procedural) t)
          
            (let* ((new-prod (if (and (or (production-dynamic p1) (production-dynamic p2)) dynamic) ;; double-check
                                 (with-unchecked-p* (p*-fct  (reverse new-p)))
                               (p-fct (reverse new-p))))
                   (p3 (get-production new-prod)))
              (setf (procedural-delay-tree procedural) nil)
              
              (when p3
                (update-params-for-compiled-production p3 new-prod p1 p2 module procedural)))))))))

  
(defun update-params-for-compiled-production (p3 new-prod p1 p2 module procedural)
  (let ((exists (check-for-duplicate-productions new-prod)))
    
    (cond ((null exists)
           ;; New production 
           (when (compilation-module-trace module)
             (model-output "  New production:~%")
             (when (car (no-output (sgp :v)))
               (pp-fct (list new-prod))))
           
           ; add it to the tree since that was suppressed
           (when (and (procedural-use-tree procedural) (not (procedural-delay-tree procedural)))
             (add-production-to-tree p3 procedural))
           
           ;mark it as a compiled productions
                       
           (setf (production-user-created new-prod) nil)
           
           ; initialize-stats for new-prod
           
           (initialize-utility-for-compiled-production new-prod (production-name p1) (production-name p2))
           
           (when (and (compilation-module-trace module)
                      (car (no-output (sgp :v))))
             (spp-fct (list new-prod))))
          
          ((null (production-user-created exists))
                       
           ;; recreation of a previously compiled
           
           (when (compilation-module-trace module)
             (model-output "  Recreating production ~a" exists))
           
           (setf (procedural-delay-tree procedural) t)
           (delete-production new-prod)
           (release-name-fct new-prod)
           (setf (procedural-delay-tree procedural) nil)
           
           (update-utility-for-compiled-production exists (production-name p1) (production-name p2))
                         
           (when (and (compilation-module-trace module)
                      (car (no-output (sgp :v))))
             (spp-fct (list exists))))
          
          (t 
           ;;recreation of a user production
           
           (when (compilation-module-trace module)
             (model-output "  Result is production ~a~%  No actions taken." exists)) 
           
           (setf (procedural-delay-tree procedural) t)
           (delete-production new-prod)
           (release-name-fct new-prod)
           (setf (procedural-delay-tree procedural) nil)))))

(defun new-production-name ()
  (loop (let ((name (new-name production)))
          (unless (get-production name)
            (return name)))))


(defun replace-variables-special (arg bindings)
  (let ((res (list nil nil)))
    (dolist (x (first arg))
      (push-last  (if (or (eql (car x) '!safe-eval!)
                          (eql (car x) '!safe-bind!))
                      (replace-variables-for-eval x bindings)
                    (replace-variables x bindings))
                 (first res)))
    (dolist (x (second arg))
      (push-last  (if (or (eql (car x) '!safe-eval!)
                          (eql (car x) '!safe-bind!))
                      (replace-variables-for-eval x bindings)
                    (replace-variables x bindings))
                 (second res)))
    res))
    
                          

(defun sort-conditions (conditions-list)
  (let ((new-conditions (copy-tree conditions-list)))
    ;(pprint new-conditions)
    (sort new-conditions #'string< :key #'(lambda (x)
                                            (let ((val (string (car x))))
                                              (if (eql #\! (aref val 0))
                                                  "z"
                                                val))))))

(defun sort-actions (actions-list)
  (let ((new-actions (copy-tree actions-list)))
    (stable-sort new-actions #'string> :key (lambda (x) (string (car x))))))

(defun check-for-duplicate-productions (prod-name)
  (let ((p (get-production prod-name)))
    (dolist (old-p (all-productions) nil)
      (unless (equal old-p prod-name)
        (when (equivalent-productions-p (get-production old-p) p)
          (return-from check-for-duplicate-productions old-p))))))



(defun equivalent-productions-p (p1 p2)
  ;; Check the easy stuff first to
  ;; hopefully be faster
  
  (unless (production-buffer-indices p1)
    (get-buffer-index p1 nil))
  (unless (production-buffer-indices p2)
    (get-buffer-index p2 nil))
  
  
  (when (and (= (length (remove-buffers (production-variables p1)))
                (length (remove-buffers (production-variables p2))))
             (= (length (production-lhs p1))
                (length (production-lhs p2)))
             (= (length (production-rhs p1))
                (length (production-rhs p2)))
             (equal (production-buffer-indices p1)
                    (production-buffer-indices p2)))
    
    (let ((mappings1 (mapcar #'(lambda (x) (cons x '&&dummy&&))
                       (remove-buffers (production-variables p1))))
          (mappings2 (mapcar #'(lambda (x) (cons x '&&dummy&&))
                       (remove-buffers (production-variables p2))))
          (s1 (produce-standard-representation p1))
          (s2 (produce-standard-representation p2)))
      
      
      
      ;; Check the overall structure 
      (unless (= (length (union (replace-variables (copy-tree s1) mappings1)
                                (replace-variables (copy-tree s2) mappings2) :test #'equalp))
                 (length s1))
        
        (return-from equivalent-productions-p nil))
      
      
      
      (setf mappings1 (mapcar #'(lambda (x) (replace-variables (copy-tree s1) (cons (cons (car x) '&&VAR&&) (remove (car x) mappings1 :key #'car))))
                        mappings1))
      (setf mappings2 (mapcar #'(lambda (x) (replace-variables (copy-tree s2) (cons (cons (car x) '&&VAR&&) (remove (car x) mappings2 :key #'car))))
                        mappings2))
      
      
      ;;; Fix the issue with differently "ordered" productions not showing as equivalent i.e.
      ;;; (p test1 =goal> isa count-from count =a count =b !eval! (pprint =a) ==> =goal> end =b)
      ;;; (p test2 =goal> isa count-from count =b count =a !eval! (pprint =b) ==> =goal> end =a)
       
      (setf mappings1 (remove-unneeded-variables mappings1))
      (setf mappings2 (remove-unneeded-variables mappings2))
      
      
      (unless (= (length (union mappings1 mappings2 :test #'equalp))
                 (length mappings1))
        (return-from equivalent-productions-p nil))
      
      t)))
        

(defun remove-unneeded-variables (mapping)
  (let ((res nil))
    (dolist (var mapping)
      (let ((conds nil)
            (acts nil))
        (dolist (x (first var))
          (when (recursive-find '&&VAR&& x)
            (push
             (case (aref (string (car x)) 0)
               (#\! x)
               (t
                (list (car x) (remove-if-not #'(lambda (y)
                                                 (find '&&VAR&& y))
                                             (second x)))))
             conds)))
        (dolist (x (second var))
          (when (recursive-find '&&VAR&& x)
            (push
             (case (aref (string (car x)) 0)
               (#\! x)
               (t
                (list (car x) (remove-if-not #'(lambda (y)
                                                 (find '&&VAR&& y))
                                             (second x)))))
             acts)))
        (push (list conds acts) res)))
    res))
        
                         
                         
(defun get-buffer-composition-type (buffer)
  (aif (get-module production-compilation)
       (aif (gethash buffer (compilation-module-buffer-type-table it))
            it
            (print-warning "No type for buffer ~S found" buffer))
       (print-warning "Production compilation module not found")))


(defun recursive-find (item list)
  (if (listp list)
      (some #'(lambda (x) (recursive-find item x)) list)
    (eq item list)))


(defun get-mapping-function (buffer)
  (let ((style (get-buffer-composition-type buffer)))
    (aif (gethash style *buffer-mapping-table*)
         it
         (progn
           (print-warning "No mapping function defined for ~a buffer of style ~a"
                          buffer style)))))

(defun get-composing-function (buffer)
  (let ((style (get-buffer-composition-type buffer)))
    (aif (gethash style *buffer-composers-table*)
         it
         (progn
           (print-warning "No composing function defined for ~a buffer of style ~a"
                          buffer style)))))


(defun rename-variables (p vars not-vars)
  (do* ((x vars (cdr x))
        (new-var (do ((new-var (new-name-fct (car x))
                               (new-name-fct (car x))))
                     ((not (find new-var not-vars)) new-var))
                 (do ((new-var (new-name-fct (car x))
                               (new-name-fct (car x))))
                     ((not (find new-var not-vars)) new-var))
                 )
        (bindings (list (cons (car x) new-var))
                  (push (cons (car x) new-var) bindings)))
       ((null (cdr x))
        (values (replace-variables p bindings) bindings))))

(defun remove-buffers (vars)
  (let ((module (get-module production-compilation)))
    (remove-if #'(lambda (x)
                   (and (find x *buffer-var-names*)
                        (not (eq 'retrieval (gethash (intern (subseq (symbol-name x) 1)) (compilation-module-buffer-type-table module))))))                
               vars)))



(defun produce-standard-representation (production)
  "This should be part of the general parsing, but for now doing after the fact
   assumes that conditions and actions aren't duplicated"
    (aif (production-standard-rep production)
         it
         (let ((parse nil)
               (lhs nil)
               (rhs nil))
           (dolist (c (production-lhs production))
             (push (list (convert-cmd (car c))
                         (case (caar c)
                           (#\= (append (list (subseq (second c) 0 2)) (sort (copy-tree (fifth c)) #'string< :key #'slot-to-string)))
                           (#\? (sort (copy-tree (append (third c) (fourth c))) #'string< :key #'slot-to-string))
                           (#\! (second c))))
                   lhs))
           (dolist (a (production-rhs production))
             (push (list (convert-cmd (car a))
                         (cond ((null (second a)) nil)
                               ((eq #\! (caar a))
                                (second a))
                               ((= (length (second a)) 1)
                                (second a))
                               ((eq (car (second a)) 'isa)
                                (append (list (subseq (second a) 0 2)) (sort (copy-tree (chunk-spec-slot-spec (define-variable-chunk-spec-fct (second a))))
                                      #'string< :key #'slot-to-string)))
                               (t ;; modification either = or +
                                (sort (modification-pairs (second a))
                                      #'string< :key #'slot-to-string))))
                   rhs))
           (push (sort rhs #'string< :key #'(lambda (x) (string (car x)))) parse)
           (push (sort lhs #'string< :key #'(lambda (x) (string (car x)))) parse)
           
           (setf (production-standard-rep production) parse))))

(defun slot-to-string (slot-list)  
  "Converts a list of items to a string with the gaps replaced with %%%"
  (format nil "~{~A%%%~}" slot-list))

(defun convert-cmd (cmd-cons)
  "Converts a cons of command identifier and command to the production symbol"
  (read-from-string (if (eq #\! (car cmd-cons))
                        (format nil "!~a!" (cdr cmd-cons))
                      (format nil "~c~a>" (car cmd-cons) (cdr cmd-cons)))))
  
(defun modification-pairs (mod-list)  
  (let ((res nil))
    (while mod-list
      (push-last (list (pop mod-list) (pop mod-list)) res))
    res))


(defun compose-goal-buffer (p1 p1-s p2 p2-s buffer)
  (declare (ignore p2))
  ;; This is based on the limited set of conditions that can
  ;; be composed.
  ;;
  ;; Generally:
  ;;   If the first has a + (4, 12, 13) then
  ;;      the conditions are those of the first
  ;;      the actions are the = of the first if there
  ;;      is one and
  ;;      the + will be the + of the first (can't be a + in the second)
  ;;      with the ='s of the second unioned in and overriding
  ;;   If the first has no actions (0, 8)
  ;;      the conditions are the union of those in the first
  ;;      and those of the second
  ;;      the actions are those of the second
  ;;   Otherwise (9)
  ;;      the conditions are the union of those in the first
  ;;      and those from the second that are not set by the 
  ;;      actions of the first
  ;;      the actions are the = from the first with the = from
  ;;      the second unioned in and overriding and
  ;;      the + of the second if there is one
  ;;
  (let* ((bn (intern (concatenate 'string (symbol-name buffer) ">")))
         (b= (intern (concatenate 'string "=" (symbol-name bn))))
         (b+ (intern (concatenate 'string "+" (symbol-name bn))))
         
         (c1 (copy-tree (find b= (first p1-s) :key #'car)))
         (c2 (copy-tree (find b= (first p2-s) :key #'car)))
         (a1= (copy-tree (find b= (second p1-s) :key #'car)))
         (a2= (copy-tree (find b= (second p2-s) :key #'car)))
         (a1+ (copy-tree (find b+ (second p1-s) :key #'car)))
         (a2+ (copy-tree (find b+ (second p2-s) :key #'car))))
    
    ;(format t "~%~{~S~%~}" (list bn b= b+ c1 c2 a1= a2= a1+ a2+))
    

    (case (aif (cdr (assoc buffer (production-buffer-indices p1))) it 0)
      ((4 12 13)
       ;(pprint (list 4 12 13))
       (list (when c1 (list c1))
             (append (when a1= (list a1=)) (awhen (buffer+-union a1+ a2=) (list it)))))
      ((0 8)
       ;(pprint (list 0 8))
       (list (awhen (buffer-condition-union c1 c2 a1=) (list it))
             (append (when a2= (list a2=)) (when a2+ (list a2+)))))
      (9
       ;(pprint (list 9))
       
       (list (awhen (buffer-condition-union c1 c2 a1=) (list it))
             (append (awhen (buffer=-union a1= a2=) (list it)) (when a2+ (list a2+))))))))


(defun buffer+-union (a1 a2)
  (dolist (mod (second a2))
    (when (find-if #'(lambda (x)
                       (and (eq (car x) '=)
                            (eq (second x) (car mod))))
                   (second a1))
      (setf (second a1) (remove-if #'(lambda (x)
                                       (and (eq (car x) '=)
                                            (eq (second x) (car mod))))
                                   (second a1))))
    (setf (second a1) (append (second a1) (list (list '= (first mod) (second mod))))))
  a1)
      
         
(defun buffer=-union (a1 a2)
  (dolist (mod (second a2))
    (when (find (car mod) (second a1) :key #'car)
      (setf (second a1) (remove (car mod) (second a1) :key #'car)))
    (setf (second a1) (append (second a1) (list mod))))
  a1)

(defun buffer-condition-union (c1 c2 a1)
  ;; remove the isa test from c2
  (unless (or (null c1) (null c2))
    (setf (second c2) (remove 'isa (second c2) :key #'first)))
  
  ;; First remove those elements of c2 set in a1
  (dolist (mod (second a1))
    (when (find-if #'(lambda (x)
                       (eq (second x) (car mod)))
                   (second c2))
      (setf (second c2) (remove-if #'(lambda (x)
                                       (eq (second x) (car mod)))
                                   (second c2)))))
  (if (null c1)
      c2
    ;; Then add the remaining elements of c2 to c1
    (progn
      (setf (second c1) (remove-duplicates (append (second c1) (second c2)) :test #'equal))
      c1)))

         
         
(defun compose-retrieval-buffer (p1 p1-s p2 p2-s buffer)
  ;; This is based on the limited set of conditions that can
  ;; be composed.
  ;;
  ;; The constraints are:
  ;;
  ;;   The only action that will remain is a
  ;;      request from the second production if such exists 
  ;;    or
  ;;      a request from the first if the second doesn't 
  ;;      harvest the buffer
  ;;
  ;;   If the first production doesn't mention the buffer (0)
  ;;      any = condition and any query are used from the second
  ;;   If the first production makes a request without a query (4, 12)
  ;;      any = condition in the first production is used and there
  ;;      are no queries
  ;;   If the first production tests the buffer but doesn't make
  ;;      any queries or requests (8)
  ;;      any = condition in the first is used along with any 
  ;;      query from the second
  ;;   If the first has no = condition but does have queries 
  ;;      and is without a request (16)
  ;;      the = condition from the second is used along with
  ;;      the query from the first
  ;;   If the first has both an = condition and a query or a
  ;;      query and a request (20, 24, 28)
  ;;      Both the = condition and query from the first are used
    
  
  (let* ((bn (intern (concatenate 'string (symbol-name buffer) ">")))
         (b= (intern (concatenate 'string "=" (symbol-name bn))))
         (b+ (intern (concatenate 'string "+" (symbol-name bn))))
         (b? (intern (concatenate 'string "?" (symbol-name bn))))

         (c1 (copy-tree (find b= (first p1-s) :key #'car)))
         (c2 (copy-tree (find b= (first p2-s) :key #'car)))
         (q1 (copy-tree (find b? (first p1-s) :key #'car)))
         (q2 (copy-tree (find b? (first p2-s) :key #'car)))

         (a1+ (copy-tree (find b+ (second p1-s) :key #'car)))
         (a2+ (copy-tree (find b+ (second p2-s) :key #'car))))
    
    ;(format t "~%~{~S~%~}" (list bn b= b+ b? c1 c2 q1 q2 a1+ a2+))

    
    (case (aif (cdr (assoc buffer (production-buffer-indices p1))) it 0)
      (0 
     ;  (pprint (list 0))
       
       (list (append (when c2 (list c2)) (when q2 (list q2)))  
             (when a2+ (list a2+))))
      ((4 12)
       ;(pprint (list 4 12))
       (if (find (aif (cdr (assoc buffer (production-buffer-indices p2))) it 0) '(0 2 4 6 16 18 20 22))
           (list (when c1 (list c1))
                 (when a1+ (list a1+)))
         (list (when c1 (list c1))
               (when a2+ (list a2+)))))
      (8
      ; (pprint (list 8))
       (list (append (when c1 (list c1)) (when q2 (list q2)))
             (when a2+ (list a2+))))
      (16
       ;(pprint (list 16))
              (list (append (when c2 (list c2)) (when q1 (list q1)))
             (when a2+ (list a2+))))
      ((20 24 28)
       ;(pprint (list 20 24 28))
       
       (if (find (aif (cdr (assoc buffer (production-buffer-indices p2))) it 0) '(0 2 4 6 16 18 20 22))
           (list (append (when c1 (list c1)) (when q1 (list q1)))
                 (when a1+ (list a1+)))
         (list (append (when c1 (list c1)) (when q1 (list q1)))
               (when a2+ (list a2+))))
       
       ))))



(defun compose-perceptual-buffer (p1 p1-s p2 p2-s buffer)
  (declare (ignore p2))
   ;; This is based on the limited set of conditions that can
  ;; be composed.
  ;;
  ;; There are no buffer modification actions allowed.
  ;;
  ;; The constraints are:
  ;;
  ;;
  ;;   If the first production doesn't mention the buffer 
  ;;      or make a request (0)
  ;;      any = condition, query and action are used from the second
  ;;   If the first production makes a request without a query (4, 12)
  ;;      any = condition in the first production is used, there
  ;;      are no queries and the action from the first is used
  ;;   If the first production tests the buffer but doesn't make
  ;;      any queries or requests (8)
  ;;      any = condition in the first is used along with any 
  ;;      query from the second and the action of the second
  ;;   If the first a query and no request (16, 24)
  ;;      any = condition in either (there can be at most 1) is used 
  ;;      along with the query from the first and the action
  ;;      of the second
  ;;   If the first has both a query and a request (20, 28)
  ;;      the = condition query and action from the first are used
    
  
  (let* ((bn (intern (concatenate 'string (symbol-name buffer) ">")))
         (b= (intern (concatenate 'string "=" (symbol-name bn))))
         (b+ (intern (concatenate 'string "+" (symbol-name bn))))
         (b? (intern (concatenate 'string "?" (symbol-name bn))))

         (c1 (copy-tree (find b= (first p1-s) :key #'car)))
         (c2 (copy-tree (find b= (first p2-s) :key #'car)))
         (q1 (copy-tree (find b? (first p1-s) :key #'car)))
         (q2 (copy-tree (find b? (first p2-s) :key #'car)))

         (a1+ (copy-tree (find b+ (second p1-s) :key #'car)))
         (a2+ (copy-tree (find b+ (second p2-s) :key #'car))))
    
    (case (aif (cdr (assoc buffer (production-buffer-indices p1))) it 0)
      (0 
       (list (append (when c2 (list c2)) (when q2 (list q2)))  
             (when a2+ (list a2+))))
      ((4 12)
       (list (when c1 (list c1))
             (when a1+ (list a1+))))
      (8
       (list (append (when c1 (list c1)) (when q2 (list q2)))
             (when a2+ (list a2+))))
      ((16 24)
       (list (append (awhen (buffer-condition-union c1 c2 nil) (list it)) (when q1 (list q1)))
             (when a2+ (list a2+))))
      ((20 28)
       (list (append (when c1 (list c1)) (when q1 (list q1)))
             (when a1+ (list a1+)))))))


(defun compose-motor-buffer (p1 p1-s p2 p2-s buffer)
  (declare (ignore p2))
  ;; This is based on the limited set of conditions that can
  ;; be composed.
  ;;
  ;; There are no buffer tests or modification actions allowed.
  ;;
  ;; The constraints are:
  ;;
  ;;   If the first production doesn't make a query 
  ;;      or make a request (0)
  ;;      any query and action are used from the second
  ;;   If the first production makes a request without a query (4)
  ;;      there is no query and the action from the first is used
  ;;   If the first has a query and no request (16)
  ;;      the query from the first and the action
  ;;      of the second are used 
  ;;   If the first has both a query and a request (20)
  ;;      the query and action from the first are used
    
  
  (let* ((bn (intern (concatenate 'string (symbol-name buffer) ">")))
         (b+ (intern (concatenate 'string "+" (symbol-name bn))))
         (b? (intern (concatenate 'string "?" (symbol-name bn))))

         (q1 (copy-tree (find b? (first p1-s) :key #'car)))
         (q2 (copy-tree (find b? (first p2-s) :key #'car)))

         (a1+ (copy-tree (find b+ (second p1-s) :key #'car)))
         (a2+ (copy-tree (find b+ (second p2-s) :key #'car))))
    
    (case (aif (cdr (assoc buffer (production-buffer-indices p1))) it 0)
      (0 
       (list (when q2 (list q2))  
             (when a2+ (list a2+))))
      (4
       (list nil
             (when a1+ (list a1+))))
      (16 
       (list (when q1 (list q1))  
             (when a2+ (list a2+))))
      
      (20
       (list (when q1 (list q1))  
             (when a1+ (list a1+)))))))





(defun map-goal-buffer (p1 p1-s p2 p2-s buffer)
  "map references from p1 to p2 for goal style buffer"
  ;; With the current restricted set of productions
  ;; that could be composed it's the case that
  ;; we only need to go from: a RHS + to a
  ;; LHS = (includes when the RHS has both + and =),
  ;; from a RHS = to a LHS = or from a LHS = with
  ;; null RHS to a LHS =.  All other cases are ignoreable.
  
  (let ((p1-style (cdr (assoc buffer (production-buffer-indices p1))))
        (p2-style (cdr (assoc buffer (production-buffer-indices p2)))))
    
    (cond (;; The RHS + to LHS = case
           (and (find p1-style '(4 12 13))
                (find p2-style '(8 9 12 13)))
           
           ;; Map the RHS +'s with the LHS ='s
           
           
           ;; here the slots of interest are just the intersection 
           ;; of the two sets
           ;;
           
           (let* ((mappings nil)
                  (p1-slots (cadr (find (intern (concatenate 'string "+" (symbol-name buffer) ">")) (second p1-s) :key #'car)))
                  (p2-slots (cadr (find (intern (concatenate 'string "=" (symbol-name buffer) ">")) (first p2-s) :key #'car)))
                  (interesting-slots (intersection (mapcan #'(lambda (x)
                                                              (when (eq (car x) '=)
                                                                (list (second x))))
                                                     p1-slots)
                                                  (mapcan #'(lambda (x)
                                                              (when (eq (car x) '=)
                                                                (list (second x))))
                                                    p2-slots))))
             
             
             ;(format t "P1-slots ~S~%p2-slots ~S~%Interesting slots ~S~%"
             ;  p1-slots
             ;  p2-slots 
             ;  interesting-slots)
             
             (dolist (slot interesting-slots)
               (dolist (p1slots (remove-if-not #'(lambda (x) (and (eq (first x) '=) (eq (second x) slot))) p1-slots))
                 (dolist (p2slots (remove-if-not #'(lambda (x) (and (eq (first x) '=) (eq (second x) slot))) p2-slots))
                   (if (constant-value-p (third p2slots))
                       (push (cons (third p1slots) (third p2slots)) mappings)
                     (push (cons (third p2slots) (third p1slots)) mappings)))))
             
             mappings
           )
           
           
           )
          (;; The RHS = to a LHS = case
           (and (find p1-style '(9))
                (find p2-style '(8 9 12 13)))
           
           ;; Map the RHS ='s and LHS ='s not in the RHS with
           ;; the LHS ='s
           
           ;; Here the slots of interest are the union of the
           ;; p1 bits with the RHS superseding the LHS intersected
           ;; with the LHS of the second one
           
           
           (let* ((mappings nil)
                  (p1-slotsa (cadr (find (intern (concatenate 'string "=" (symbol-name buffer) ">")) (first p1-s) :key #'car)))
                  (p1-slotsb (cadr (find (intern (concatenate 'string "=" (symbol-name buffer) ">")) (second p1-s) :key #'car)))
                  (p2-slots (cadr (find (intern (concatenate 'string "=" (symbol-name buffer) ">")) (first p2-s) :key #'car)))
                  
                  (p1-slots (append (remove-if #'(lambda (x)
                                                   (or (not (eq (car x) '=))
                                                       (find (second x) p1-slotsb :key #'car)))
                                               p1-slotsa)
                                    (mapcar #'(lambda (x)
                                                (append (list '=) x))
                                      p1-slotsb)))
                  (interesting-slots  (intersection (mapcan #'(lambda (x) (list (second  x)))
                                                      p1-slots)
                                                    (mapcan #'(lambda (x)
                                                                (when (eq (car x) '=)
                                                                  (list (second x))))
                                                      p2-slots))))
             
             
            ; (format t "P1-slotsa ~S~%P1-slotsb ~S~%P1-slots  ~S~%p2-slots ~S~%Interesting slots ~S~%"
            ;   p1-slotsa
            ;   p1-slotsb
            ;   p1-slots
            ;   p2-slots 
            ;   interesting-slots)
             
             (dolist (slot interesting-slots)
               (dolist (p1slots (remove-if-not #'(lambda (x) (eq (second x) slot)) p1-slots))
                 (dolist (p2slots (remove-if-not #'(lambda (x) (eq (second x) slot)) p2-slots))
                   (if (constant-value-p (third p2slots))
                       (push (cons (third p1slots) (third p2slots)) mappings)
                     (push (cons (third p2slots) (third p1slots)) mappings)))))
             
             mappings)
             
           
           )
          (;; The LHS = RHS null to a LHS = case
           (and (find p1-style '(8))
                (find p2-style '(8 9 12 13)))
           
           ;; Map the LHS ='s with the LHS ='s
           
           
           ;; The slots of interest are the ones at the intersection of the
           ;; two sets - the mappings are then done for those
           ;; such that 
           ;;   - if it's a variable in both then p2 vars go to p1 vars 
           ;;   - if it's a constant in one then it goes from the var to the constant
           ;;     (note that buffer variables are considered constants and not variables)
           ;;   - if it's a constant in both we're in trouble if they aren't equal
           ;;     because how did they fire...
           ;;
           ;; When there is more than one option we have to add both but they need to
           ;; be evaluated in the order of variables before constants (that's handled
           ;; elsewhere though)
           
           
           (let* ((mappings nil)
                  (p1-slots (cadr (find (intern (concatenate 'string "=" (symbol-name buffer) ">")) (first p1-s) :key #'car)))
                  (p2-slots (cadr (find (intern (concatenate 'string "=" (symbol-name buffer) ">")) (first p2-s) :key #'car)))
                  (interesting-slots (intersection (mapcan #'(lambda (x)
                                                              (when (eq (car x) '=)
                                                                (list (second x))))
                                                    p1-slots)
                                                  (mapcan #'(lambda (x)
                                                              (when (eq (car x) '=)
                                                                (list (second x))))
                                                    p2-slots))))
             
             
             ;(format t "P1-slots ~S~%p2-slots ~S~%Interesting slots ~S~%"
             ;  p1-slots
             ;  p2-slots 
             ;  interesting-slots)
             
             (dolist (slot interesting-slots)
               (dolist (p1slots (remove-if-not #'(lambda (x) (and (eq (first x) '=) (eq (second x) slot))) p1-slots))
                 (dolist (p2slots (remove-if-not #'(lambda (x) (and (eq (first x) '=) (eq (second x) slot))) p2-slots))
                   (if (constant-value-p (third p2slots))
                       (push (cons (third p1slots) (third p2slots)) mappings)
                     (push (cons (third p2slots) (third p1slots)) mappings)))))
             
             mappings

           ))
          (t
           nil))))



(defun constant-value-p (val)
  (let ((buffer-vars (mapcar #'(lambda (x)
                                 (read-from-string (format nil "=~a" x)))
                       (buffers))))
    (or (not (chunk-spec-variable-p val))
        (find val buffer-vars))))

(defun map-retrieval-buffer (p1 p1-s p2 p2-s buffer)
  "map references from p1 to p2 for retrieval style buffer"
  ;; current specification will only allow this
  ;; in the case that it's a RHS + or nothing
  ;; combined with a LHS = or "busy" query.
  ;;
  ;; Then, the only time there are mappings are
  ;; when it's a + followed by an =.
  
  ;(format t "Buffer is: ~s~%" buffer)
  
  (let ((module (get-module production-compilation))
        (p1-style (cdr (assoc buffer (production-buffer-indices p1))))
        (p2-style (cdr (assoc buffer (production-buffer-indices p2)))))
    
    (cond ((and (find p1-style '(4 12 20 28))
                (find p2-style '(8 12 24 28)))
           
           ;; map variables onto constants of retrieved chunk
           
           (let* ((buffer-variable (intern (concatenate 'string "=" (symbol-name buffer))))
                  (the-chunk (cdr (assoc buffer-variable (production-bindings p2)))))
             
             (when the-chunk
               
               (let ((mappings (if (find buffer-variable (production-retrieval-buffers-map (production-name p2)) :key #'car)
                                   (list (cons (cdr (find buffer-variable (production-retrieval-buffers-map (production-name p2)) :key #'car))
                                               the-chunk))
                                   (list (cons buffer-variable the-chunk)))))
                 
                 
                 ;(format t "bindings of p1: ~S~%" (production-bindings p1))
                 
                 ;(format t "bindings of p2: ~S~%" (production-bindings p2))
                 
                 ;(format t "Previous: ~S ~%" (compilation-module-previous module))
                 
                 ;(production-bindings p2)
                 
                 (dolist (condition (cadr (find (intern (concatenate 'string "+" (symbol-name buffer) ">")) (second p1-s) :key #'car)))
                   
                   ;(format t "What?: ~S~%" condition)
                   
                   (when (chunk-spec-variable-p (second condition))
                     
                     
                     ;; Variablized slot needs to be instantiated...
                     
                     (push (assoc (second condition) (second (compilation-module-previous module))) mappings)
                     
                     
                     )
                   
                   
                   (when (and (eq (car condition) '=)
                              (chunk-spec-variable-p (third condition)))
                     ;; Update to handle partial matching
                     ;; get the binding for the action from the first production's 
                     ;; instantiation instead of what's retrieved in the buffer
                     ;(push (cons (third condition) (chunk-slot-value-fct the-chunk (second condition))) mappings)
                     
                     (push (assoc (third condition) (second (compilation-module-previous module))) mappings)
                     
                     ))
                 
                 
                 
                 (dolist (condition (cadr (find (intern (concatenate 'string "=" (symbol-name buffer) ">")) (first p2-s) :key #'car)))
                   
                   ;(format t "COndition:  ~S~%" condition)
                   
                   ;; Bind a variablized slot to its instantiation
                   
                   (when (chunk-spec-variable-p (second condition))
                     (push (assoc (second condition) (production-compilation-instan (production-name p2))) mappings))
                   
                   (when (and (eq (car condition) '=)
                              (chunk-spec-variable-p (third condition)))
                     (if (chunk-spec-variable-p (second condition))
                         ;; if the slot name is a variable we need to use the instantiation of
                         ;; that to know what the real slot name was
                         (push (cons (third condition) (chunk-slot-value-fct the-chunk (cdr (assoc (second condition) mappings)))) mappings)
                         
                       (push (cons (third condition) (chunk-slot-value-fct the-chunk (second condition))) mappings)))
                 )
                 
                 ;(format t "Mappings: ~S~%" mappings)
                 
                 mappings))))
          (t
           nil))))

(defun map-perceptual-buffer (p1 p1-s p2 p2-s buffer)
  "map references from p1 to p2 for perceptual style buffer"
  (declare (ignore p1 p2 p1-s p2-s buffer))
  ;; current specification prevents there from
  ;; being any need to do such mappings because
  ;; a RHS = prevents composition and
  ;; a RHS + can't be composed with a LHS =
  nil
  )

(defun map-motor-buffer (p1 p1-s p2 p2-s buffer)
  "map references from p1 to p2 for motor style buffer"
  (declare (ignore p1 p2 p1-s p2-s buffer))
  ;; current specification prevents there from
  ;; being any need to do such mappings because
  ;; any buffer reference prevents composition
  nil
  )



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Support code for generating the tables and such.
;;; It's not used in the system but for generating this file and related
;;; materials.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#|

Print out the condition/action displays and numbering

(let ((lhs '("{}" "=" "?" "=.?"))
      (rhs '("{}" "=" "-" "=.-" "+" "=.+" "-.+" "=.-.+")))
  (dotimes (i (length lhs))
    (dotimes (j (length rhs))
      (format t "~2d  ~A>~a~%" (+ (* 8 i) j) (nth i lhs) (nth j rhs)))))

 0  {}>{}
 1  {}>=         INVAILD
 2  {}>-
 3  {}>=.-       INVAILD
 4  {}>+
 5  {}>=.+       INVAILD
 6  {}>-.+
 7  {}>=.-.+     INVAILD
 8  =>{}
 9  =>=
10  =>-
11  =>=.-
12  =>+
13  =>=.+
14  =>-.+
15  =>=.-.+
16  ?>{}
17  ?>=         INVAILD
18  ?>-
19  ?>=.-       INVAILD
20  ?>+
21  ?>=.+       INVAILD
22  ?>-.+
23  ?>=.-.+     INVAILD
24  =.?>{}
25  =.?>=
26  =.?>-
27  =.?>=.-
28  =.?>+
29  =.?>=.+
30  =.?>-.+
31  =.?>=.-.+


Call this with a list of the tab delimited files for the pages of
the excel spreadsheet that defines the legal compositions.  It outputs the
text for the two initializer functions.

(defun build-initializers (file-list)
  (let ((composer-table nil)
        (mapping-table nil))
    (format t "(defun initialize-compose-table ()~%")
    (format t 
        "   \"Function that initializes the table of legal buffer compositions.~%")
    (format t "    DO NOT MODIFY THIS FUNCTON DIRECTLY - BUILD IT USING~%")
    (format t "    THE build-initializers FUNCTION AND THE SPREADSHEETS.\"~%")
    
    (dolist (file file-list)
      ; Since this isn't a user function it forgoes a lot of error checking
      (with-open-file (f file :direction :input)
        (let ((style (read f)))
          (format t "  ;; style: ~s~%" style)
          (format t "  (unless (find '~a +valid-compilation-buffer-types+)~%" style)
          (format t "      (print-warning \"Invalid buffer style ~a\"))~%" style)
          
          (format t "  (setf (gethash '~a *valid-compose-table*) (make-hash-table :test #'equalp))~%" style)
          (push (cons style (read f)) mapping-table)
          (push (cons style (read f)) composer-table)
          (read-line f)
          (read-line f)
          (read-line f)
          (let ((p2-indices 
                 (do* ((l nil)
                       (s (make-string-input-stream (read-line f)))
                       (val (read s nil nil) (read s nil nil)))
                      ((null val) (reverse l))
                   (push val l))))
            (read-line f)
            (dotimes (i (length p2-indices))
              (let ((p1-index (read f)))
                (read f)
                (dotimes (j (length p2-indices))
                  (awhen (Read f)
                         (format t "  (setf (gethash (vector ~2d ~2d) (gethash '~a *valid-compose-table*)) '~a)~%" 
                           p1-index (nth j p2-indices) style it)))))))))
    (format t ")~%")
    
    (format t "(defun initialize-mappers-table ()~%")
    (format t 
        "   \"Function that initializes the table of buffer composition mapping functions.~%")
    (format t "    DO NOT MODIFY THIS FUNCTON DIRECTLY - BUILD IT USING~%")
    (format t "    THE build-initializers FUNCTION AND THE SPREADSHEETS.\"~%")
    (dolist (c mapping-table)
      (format t "  (setf (gethash '~a *buffer-mapping-table*) '~a)~%"
        (car c) (cdr c)))
    (format t ")~%")
        
    (format t "(defun initialize-composers-table ()~%")
    (format t 
        "   \"Function that initializes the table of buffer composition functions.~%")
    (format t "    DO NOT MODIFY THIS FUNCTON DIRECTLY - BUILD IT USING~%")
    (format t "    THE build-initializers FUNCTION AND THE SPREADSHEETS.\"~%")
    (dolist (c composer-table)
      (format t "  (setf (gethash '~a *buffer-composers-table*) '~a)~%"
        (car c) (cdr c)))
    (format t ")~%")))
          


|#
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; User commands
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmacro specify-compilation-buffer-type (buffer-name buffer-type)
  `(specify-compilation-buffer-type-fct ',buffer-name ',buffer-type))

(defun specify-compilation-buffer-type-fct (buffer-name buffer-type)
  (let ((module (get-module production-compilation)))
    (if module
        (cond ((not (find buffer-name (buffers)))
               (print-warning "No buffer named ~s found." buffer-name))
              ((not (find buffer-type +valid-compilation-buffer-types+))
               (print-warning "Invalid compilation buffer type ~S." buffer-type))
              (t
               (setf (gethash buffer-name 
                              (compilation-module-buffer-type-table module))
                 buffer-type)
               t))
      (print-warning "No production compilation module found"))))


(defun show-compilation-buffer-types ()
  (let ((module (get-module production-compilation)))
    (if module
        (let ((len (apply #'max (mapcar #'(lambda (x)
                                            (length (string x)))
                                  (buffers)))))
          (command-output "  ~va        Type" len "Buffer")
          (maphash #'(lambda (buffer type)
                       (command-output "~va        ~a" len buffer type))
                   (compilation-module-buffer-type-table module)))
      (print-warning "No production compilation module found"))))
          

(defmacro compilation-buffer-type (buffer-name)
  `(compilation-buffer-type-fct ',buffer-name))

(defun compilation-buffer-type-fct (buffer)
  (let ((module (get-module production-compilation)))
    (if module
          (values (gethash buffer (compilation-module-buffer-type-table module)))
      (print-warning "No production compilation module found"))))

#|
This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
|#
